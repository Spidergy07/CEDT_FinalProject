<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>PDF Study Platform ‚Äî RAG-ready</title>
  <link rel="stylesheet" href="styles.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>
<body>
  <!-- Mobile toggles (pure CSS hamburger) -->
  <input type="checkbox" id="toggle-sidebar" class="visually-hidden" />
  <input type="checkbox" id="toggle-chat" class="visually-hidden" />

  <header class="app-header">
    <div class="left">
      <label for="toggle-sidebar" class="icon-btn only-mobile" aria-label="Toggle sidebar">‚ò∞</label>
      <a class="brand" href="#">Study<span>PDF</span></a>
    </div>
    <div class="center">
      <form class="search">
        <input type="search" placeholder="Search documents or topics‚Ä¶" aria-label="Search" />
      </form>
    </div>
    <div class="right">
      <button class="btn ghost">Login</button>
      <label for="toggle-chat" class="icon-btn only-mobile" aria-label="Toggle chat">üí¨</label>
    </div>
  </header>

  <main class="app-shell">
    <!-- Sidebar: year navigation & files -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <h3>Academic Years</h3>
        <button class="close-sidebar-btn only-mobile" id="close-sidebar-btn" title="Close Sidebar">‚úï</button>
      </div>
      <div class="section">
        <ul class="year-list">
          <li class="year-item active" data-year="Year 1-1">
            <div class="year-header">
              <span class="year-icon">üìÅ</span>
              <span class="year-name">Year 1-1</span>
              <span class="year-toggle">‚ñº</span>
            </div>
            <ul class="subjects-list">
              <li class="subject-item" data-subject="Computer Programming">
                <span class="subject-icon">üíª</span>
                <span class="subject-name">Computer Programming</span>
              </li>
              <li class="subject-item" data-subject="Data Structures And Algorithms">
                <span class="subject-icon">üìä</span>
                <span class="subject-name">Data Structures And Algorithms</span>
              </li>
              <li class="subject-item" data-subject="Digital Computer Logic">
                <span class="subject-icon">üîß</span>
                <span class="subject-name">Digital Computer Logic</span>
              </li>
              <li class="subject-item" data-subject="Discrete Structures">
                <span class="subject-icon">üî¢</span>
                <span class="subject-name">Discrete Structures</span>
              </li>
              <li class="subject-item" data-subject="Introduction to CEDT">
                <span class="subject-icon">üéì</span>
                <span class="subject-name">Introduction to CEDT</span>
              </li>
            </ul>
          </li>
          <li class="year-item" data-year="Year 1-2">
            <div class="year-header">
              <span class="year-icon">üìÅ</span>
              <span class="year-name">Year 1-2</span>
              <span class="year-toggle">‚ñ∂</span>
            </div>
          </li>
          <li class="year-item" data-year="Year 2-1">
            <div class="year-header">
              <span class="year-icon">üìÅ</span>
              <span class="year-name">Year 2-1</span>
              <span class="year-toggle">‚ñ∂</span>
            </div>
          </li>
          <li class="year-item" data-year="Year 2-2">
            <div class="year-header">
              <span class="year-icon">üìÅ</span>
              <span class="year-name">Year 2-2</span>
              <span class="year-toggle">‚ñ∂</span>
            </div>
          </li>
        </ul>
      </div>
      <div class="section">
        <h3>Files</h3>
        <button class="btn" id="refresh-files-btn" style="margin-bottom: 10px; width: 100%; font-size: 12px;">üîÑ Refresh Files</button>
        <ul class="files" id="files-list">
          <!-- Files will be dynamically loaded here -->
        </ul>
      </div>
    </aside>

    <!-- Viewer: PDF area -->
    <section class="viewer">
      <div class="viewer-toolbar">
        <div class="toolbar-left">
          <strong class="doc-title">Lecture 01 ‚Äî Intro to C.pdf</strong>
        </div>
        <div class="toolbar-right">
          <button class="btn">Prev</button>
          <button class="btn">Next</button>
          <button class="btn">Zoom ‚àí</button>
          <button class="btn">Zoom +</button>
        </div>
      </div>

      <!-- PDF Viewer using PDF.js -->
      <div class="pdf-frame" id="pdf-frame">
        <div class="pdf-container" id="pdf-container">
          <canvas id="pdf-canvas"></canvas>
        </div>
        <div class="pdf-placeholder" id="pdf-placeholder">
          <div>
            <div class="ph-title">PDF Viewer</div>
            <p>Select a PDF file from the sidebar to view it here.</p>
            <p class="ph-note">Powered by PDF.js</p>
          </div>
        </div>
        <div class="pdf-loading" id="pdf-loading" style="display: none;">
          <div class="loading-spinner"></div>
          <p>Loading PDF...</p>
        </div>
        
        <!-- PDF Navigation Overlay -->
        <div class="pdf-nav-overlay" id="pdf-nav-overlay">
          <div class="pdf-nav-left" id="pdf-nav-left">
            <button class="nav-btn" id="prev-page-btn" title="Previous Page">‚Äπ</button>
          </div>
          <div class="pdf-nav-right" id="pdf-nav-right">
            <button class="nav-btn" id="next-page-btn" title="Next Page">‚Ä∫</button>
          </div>
        </div>
        
        <!-- PDF Controls Overlay -->
        <div class="pdf-controls-overlay" id="pdf-controls-overlay">
          <div class="pdf-controls">
            <button class="control-btn" id="zoom-out-btn" title="Zoom Out">‚àí</button>
            <span class="zoom-level" id="zoom-level">100%</span>
            <button class="control-btn" id="zoom-in-btn" title="Zoom In">+</button>
            <div class="page-info" id="page-info">1 / 1</div>
            <button class="control-btn" id="fit-width-btn" title="Fit Width">‚§¢</button>
            <button class="control-btn" id="fit-page-btn" title="Fit Page">‚§°</button>
            <button class="control-btn" id="zoom-window-btn" title="Zoom Window">üîç</button>
          </div>
        </div>
        
        <!-- Zoom Window Overlay -->
        <div class="zoom-window-overlay" id="zoom-window-overlay" style="display: none;">
          <div class="zoom-window-container">
            <div class="zoom-window-header">
              <div class="header-left">
                <h4>Zoom Window</h4>
                <div class="zoom-level-indicator">
                  <span id="zoom-level-indicator">200%</span>
                </div>
              </div>
              <div class="zoom-window-controls">
                <button class="zoom-window-btn" id="zoom-window-settings" title="Settings">‚öôÔ∏è</button>
                <button class="zoom-window-btn" id="zoom-window-close" title="Close">‚úï</button>
              </div>
            </div>
            
            <div class="zoom-window-main">
              <!-- PDF Preview Area -->
              <div class="pdf-preview-area" id="pdf-preview-area">
                <div class="pdf-preview-content" id="pdf-preview-content">
                  <!-- PDF preview will be rendered here -->
                </div>
                <div class="zoom-box" id="zoom-box">
                  <div class="zoom-box-content" id="zoom-box-content">
                    <!-- Zoomed content will be rendered here -->
                  </div>
                  <div class="zoom-box-resize-handles">
                    <div class="resize-handle resize-nw" data-direction="nw"></div>
                    <div class="resize-handle resize-ne" data-direction="ne"></div>
                    <div class="resize-handle resize-sw" data-direction="sw"></div>
                    <div class="resize-handle resize-se" data-direction="se"></div>
                    <div class="resize-handle resize-n" data-direction="n"></div>
                    <div class="resize-handle resize-s" data-direction="s"></div>
                    <div class="resize-handle resize-w" data-direction="w"></div>
                    <div class="resize-handle resize-e" data-direction="e"></div>
                  </div>
                </div>
              </div>
              
              <!-- Writing Area -->
              <div class="writing-area" id="writing-area">
                <div class="writing-canvas-container">
                  <canvas id="writing-canvas" width="400" height="300"></canvas>
                  <div class="writing-overlay" id="writing-overlay"></div>
                </div>
              </div>
            </div>
            
            <div class="zoom-window-settings-panel" id="zoom-window-settings-panel" style="display: none;">
              <div class="settings-section">
                <h5>Writing Settings</h5>
                <div class="setting-group">
                  <label for="return-height">Return Height:</label>
                  <input type="range" id="return-height" min="20" max="100" value="40" />
                  <span id="return-height-value">40px</span>
                </div>
                <div class="setting-group">
                  <label for="auto-advance">Auto Advance:</label>
                  <input type="checkbox" id="auto-advance" checked />
                </div>
                <div class="setting-group">
                  <label for="pressure-sensitivity">Pressure Sensitivity:</label>
                  <input type="checkbox" id="pressure-sensitivity" checked />
                </div>
                <div class="setting-group">
                  <label for="handwriting-recognition">Handwriting Recognition:</label>
                  <input type="checkbox" id="handwriting-recognition" checked />
                </div>
              </div>
              
              <div class="settings-section">
                <h5>Zoom Settings</h5>
                <div class="setting-group">
                  <label for="zoom-factor">Zoom Factor:</label>
                  <input type="range" id="zoom-factor" min="150" max="400" value="200" />
                  <span id="zoom-factor-value">200%</span>
                </div>
                <div class="setting-group">
                  <label for="zoom-box-size">Zoom Box Size:</label>
                  <select id="zoom-box-size">
                    <option value="small">Small (200x150)</option>
                    <option value="medium" selected>Medium (300x200)</option>
                    <option value="large">Large (400x300)</option>
                    <option value="custom">Custom</option>
                  </select>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Writing Tools Overlay -->
        <div class="writing-tools-overlay" id="writing-tools-overlay" style="display: none;">
          <div class="writing-tools">
            <!-- Tool Selection -->
            <div class="tool-group">
              <button class="tool-btn active" id="pen-tool" title="Pen">
                <div class="tool-icon">‚úèÔ∏è</div>
                <div class="tool-label">Pen</div>
              </button>
              <button class="tool-btn" id="highlighter-tool" title="Highlighter">
                <div class="tool-icon">üñçÔ∏è</div>
                <div class="tool-label">Highlighter</div>
              </button>
              <button class="tool-btn" id="eraser-tool" title="Eraser">
                <div class="tool-icon">üßπ</div>
                <div class="tool-label">Eraser</div>
              </button>
              <button class="tool-btn" id="lasso-tool" title="Lasso">
                <div class="tool-icon">ü™ù</div>
                <div class="tool-label">Lasso</div>
              </button>
              <button class="tool-btn" id="shape-tool" title="Shapes">
                <div class="tool-icon">‚¨ú</div>
                <div class="tool-label">Shapes</div>
              </button>
              <button class="tool-btn" id="text-tool" title="Text">
                <div class="tool-icon">T</div>
                <div class="tool-label">Text</div>
              </button>
            </div>
            
            <!-- Tool Settings -->
            <div class="tool-settings">
              <div class="setting-row">
                <label for="pen-color">Color:</label>
                <div class="color-palette">
                  <div class="color-option active" data-color="#000000" style="background: #000000"></div>
                  <div class="color-option" data-color="#FF0000" style="background: #FF0000"></div>
                  <div class="color-option" data-color="#00FF00" style="background: #00FF00"></div>
                  <div class="color-option" data-color="#0000FF" style="background: #0000FF"></div>
                  <div class="color-option" data-color="#FFFF00" style="background: #FFFF00"></div>
                  <div class="color-option" data-color="#FF00FF" style="background: #FF00FF"></div>
                  <div class="color-option" data-color="#00FFFF" style="background: #00FFFF"></div>
                  <div class="color-option" data-color="#FFA500" style="background: #FFA500"></div>
                  <input type="color" id="pen-color" value="#000000" title="Custom Color" />
                </div>
              </div>
              
              <div class="setting-row">
                <label for="pen-size">Size:</label>
                <div class="size-options">
                  <div class="size-option active" data-size="1">1</div>
                  <div class="size-option" data-size="2">2</div>
                  <div class="size-option" data-size="3">3</div>
                  <div class="size-option" data-size="5">5</div>
                  <div class="size-option" data-size="8">8</div>
                  <div class="size-option" data-size="12">12</div>
                </div>
                <input type="range" id="pen-size" min="1" max="20" value="3" title="Pen Size" />
                <span id="pen-size-value">3px</span>
              </div>
              
              <div class="setting-row">
                <label for="pen-opacity">Opacity:</label>
                <input type="range" id="pen-opacity" min="0.1" max="1" step="0.1" value="1" title="Opacity" />
                <span id="pen-opacity-value">100%</span>
              </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="action-buttons">
              <button class="action-btn" id="undo-btn" title="Undo">‚Ü∂</button>
              <button class="action-btn" id="redo-btn" title="Redo">‚Ü∑</button>
              <button class="action-btn" id="clear-btn" title="Clear">üóëÔ∏è</button>
              <button class="action-btn" id="save-btn" title="Save">üíæ</button>
            </div>
          </div>
        </div>
        
        <!-- Shape Tools Panel -->
        <div class="shape-tools-panel" id="shape-tools-panel" style="display: none;">
          <div class="shape-options">
            <button class="shape-btn active" data-shape="rectangle" title="Rectangle">‚¨ú</button>
            <button class="shape-btn" data-shape="circle" title="Circle">‚≠ï</button>
            <button class="shape-btn" data-shape="line" title="Line">üìè</button>
            <button class="shape-btn" data-shape="arrow" title="Arrow">‚û°Ô∏è</button>
            <button class="shape-btn" data-shape="star" title="Star">‚≠ê</button>
            <button class="shape-btn" data-shape="heart" title="Heart">‚ù§Ô∏è</button>
          </div>
        </div>
      </div>
    </section>

    <!-- Chat/Q&A panel -->
    <aside class="chat">
      <div class="chat-header">
        <h3>‡∏ñ‡∏≤‡∏° TA Tohtoh</h3>
      </div>
      <div class="chat-body">
        <!-- Messages will be dynamically added here -->
      </div>
      <form class="chat-input" action="#" method="get">
        <input type="text" placeholder="‡∏ñ‡∏≤‡∏°‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô..." aria-label="Ask about this PDF" />
        <button class="btn primary" type="submit">Send</button>
      </form>
    </aside>
  </main>

  <footer class="app-footer">
    <div>¬© 2025 StudyPDF ‚Ä¢ Demo UI</div>
    <nav class="foot-links">
      <a href="#">Privacy</a>
      <a href="#">Terms</a>
      <a href="#">Help</a>
    </nav>
  </footer>

  <script>
    // Study PDF Platform - Frontend JavaScript
    class StudyPDFApp {
      constructor() {
        this.apiBaseUrl = 'http://localhost:3000';
        this.chatHistory = [];
        this.isLoading = false;
        this.currentYear = 'Year 1-1';
        this.currentSubject = null;
        this.currentPdf = null;
        this.pdfDoc = null;
        this.currentPage = 1;
        this.totalPages = 0;
        this.scale = 1.0;
        this.minScale = 0.5;
        this.maxScale = 3.0;
        this.isDragging = false;
        this.dragStart = { x: 0, y: 0 };
        this.touchStart = { x: 0, y: 0 };
        this.lastTouchTime = 0;
        
        // Zoom Window properties
        this.zoomWindowActive = false;
        this.zoomBox = null;
        this.zoomBoxContent = null;
        this.zoomBoxPosition = { x: 0, y: 0 };
        this.zoomBoxSize = { width: 300, height: 200 };
        this.returnHeight = 40;
        this.autoAdvance = true;
        this.isDraggingZoomBox = false;
        this.isResizingZoomBox = false;
        this.resizeDirection = null;
        this.dragStart = { x: 0, y: 0 };
        
        // Writing tools properties
        this.currentTool = 'pen';
        this.penColor = '#000000';
        this.penSize = 3;
        this.penOpacity = 1;
        this.isDrawing = false;
        this.drawingPath = [];
        this.drawingHistory = [];
        this.currentDrawing = null;
        this.undoStack = [];
        this.redoStack = [];
        this.pressureSensitivity = true;
        this.handwritingRecognition = true;
        this.zoomFactor = 2.0;
        this.currentShape = 'rectangle';
        this.isDrawingShape = false;
        this.shapeStartPoint = null;
        this.layers = [];
        this.currentLayer = 0;
        
        this.init();
      }

      init() {
        this.setupEventListeners();
        this.loadInitialState();
      }

      setupEventListeners() {
        // Prevent iOS Safari from zooming on double-tap
        document.addEventListener('touchstart', function(e) {
          if (e.touches.length > 1) {
            e.preventDefault();
          }
        }, { passive: false });

        // Handle responsive behavior
        this.setupResponsiveHandlers();

        // Chat form submission
        const chatForm = document.querySelector('.chat-input');
        if (chatForm) {
          chatForm.addEventListener('submit', (e) => {
            e.preventDefault();
            this.handleChatSubmit();
          });
        }

        // Search form submission
        const searchForm = document.querySelector('.search');
        if (searchForm) {
          searchForm.addEventListener('submit', (e) => {
            e.preventDefault();
            this.handleSearchSubmit();
          });
        }

        // Year selection
        const yearItems = document.querySelectorAll('.year-item');
        yearItems.forEach(item => {
          // Add both click and touch events for better iPad compatibility
          item.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            this.selectYear(item);
          });
          
          item.addEventListener('touchend', (e) => {
            e.stopPropagation();
            e.preventDefault();
            this.selectYear(item);
          });
        });

        // Subject selection
        const subjectItems = document.querySelectorAll('.subject-item');
        subjectItems.forEach(item => {
          // Add both click and touch events for better iPad compatibility
          item.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log('Subject clicked:', item.dataset.subject);
            this.selectSubject(item);
          });
          
          item.addEventListener('touchend', (e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log('Subject touched:', item.dataset.subject);
            this.selectSubject(item);
          });
          
          // Add touchstart to prevent default behavior
          item.addEventListener('touchstart', (e) => {
            e.stopPropagation();
          }, { passive: true });
        });

        // PDF navigation buttons (old toolbar)
        const prevBtn = document.querySelector('.toolbar-right .btn:nth-child(1)');
        const nextBtn = document.querySelector('.toolbar-right .btn:nth-child(2)');
        const zoomOutBtn = document.querySelector('.toolbar-right .btn:nth-child(3)');
        const zoomInBtn = document.querySelector('.toolbar-right .btn:nth-child(4)');

        if (prevBtn) prevBtn.addEventListener('click', () => this.previousPage());
        if (nextBtn) nextBtn.addEventListener('click', () => this.nextPage());
        if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => this.zoomOut());
        if (zoomInBtn) zoomInBtn.addEventListener('click', () => this.zoomIn());

        // New PDF controls
        this.setupPDFControls();
        
        // Touch and mouse gestures
        this.setupPDFGestures();
        
        // Zoom window controls
        this.setupZoomWindowControls();
        
        // Writing tools controls
        this.setupWritingToolsControls();
        
        // Refresh files button
        const refreshBtn = document.getElementById('refresh-files-btn');
        if (refreshBtn) {
          refreshBtn.addEventListener('click', () => {
            if (this.currentSubject) {
              console.log('Manually refreshing files for:', this.currentSubject);
              this.loadFilesForSubject(this.currentSubject);
            } else {
              console.log('No subject selected');
            }
          });
        }
        
        // Close sidebar button
        const closeSidebarBtn = document.getElementById('close-sidebar-btn');
        if (closeSidebarBtn) {
          closeSidebarBtn.addEventListener('click', () => {
            this.closeSidebar();
          });
        }
      }

      loadInitialState() {
        // Add initial AI message
        this.addMessage('ai', '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ! ‡∏ú‡∏°‡∏Ñ‡∏∑‡∏≠ TA Tohtoh ‡∏ú‡∏π‡πâ‡∏ä‡πà‡∏ß‡∏¢‡∏™‡∏≠‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ñ‡∏≤‡∏°‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ ‡∏ú‡∏°‡∏à‡∏∞‡∏ä‡πà‡∏ß‡∏¢‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏•‡∏∞‡∏ï‡∏≠‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì');
      }

      async handleChatSubmit() {
        const input = document.querySelector('.chat-input input');
        const question = input.value.trim();
        
        if (!question || this.isLoading) return;

        // Add user message
        this.addMessage('user', question);
        input.value = '';

        // Show loading state
        this.setLoading(true);

        try {
          // Call the search-and-answer API
          const response = await fetch(`${this.apiBaseUrl}/search-and-answer`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              question: question,
              topK: 4
            })
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();
          
          // Display the answer
          this.addMessage('ai', data.answer.answer);
          
          // Update chat history
          this.chatHistory.push({
            question: question,
            answer: data.answer.answer,
            timestamp: new Date()
          });

        } catch (error) {
          console.error('Error calling API:', error);
          this.addMessage('ai', '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢ ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏° ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
        } finally {
          this.setLoading(false);
        }
      }

      async handleSearchSubmit() {
        const input = document.querySelector('.search input');
        const query = input.value.trim();
        
        if (!query) return;

        // For now, just add the search query to chat
        this.addMessage('user', `‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤: ${query}`);
        
        // You can implement search functionality here
        this.addMessage('ai', '‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏ô‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï');
        
        input.value = '';
      }

      addMessage(sender, content) {
        const chatBody = document.querySelector('.chat-body');
        const messageDiv = document.createElement('div');
        messageDiv.className = `msg ${sender}`;
        
        const bubbleDiv = document.createElement('div');
        bubbleDiv.className = 'bubble';
        bubbleDiv.textContent = content;
        
        messageDiv.appendChild(bubbleDiv);
        chatBody.appendChild(messageDiv);
        
        // Scroll to bottom
        chatBody.scrollTop = chatBody.scrollHeight;
      }

      setLoading(loading) {
        this.isLoading = loading;
        const submitBtn = document.querySelector('.chat-input button');
        const input = document.querySelector('.chat-input input');
        
        if (loading) {
          submitBtn.textContent = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...';
          submitBtn.disabled = true;
          input.disabled = true;
        } else {
          submitBtn.textContent = 'Send';
          submitBtn.disabled = false;
          input.disabled = false;
        }
      }

      async selectYear(yearItem) {
        const year = yearItem.dataset.year;
        
        // Toggle year expansion
        if (yearItem.classList.contains('active')) {
          yearItem.classList.remove('active');
          return;
        }
        
        // Remove active class from all years
        document.querySelectorAll('.year-item').forEach(item => {
          item.classList.remove('active');
        });
        
        // Add active class to selected year
        yearItem.classList.add('active');
        this.currentYear = year;
        
        // Clear files list
        this.clearFilesList();
      }

      async selectSubject(subjectItem) {
        const subject = subjectItem.dataset.subject;
        
        console.log('Selecting subject:', subject);
        
        // Remove active class from all subjects
        document.querySelectorAll('.subject-item').forEach(item => {
          item.classList.remove('active');
        });
        
        // Add active class to selected subject
        subjectItem.classList.add('active');
        this.currentSubject = subject;
        
        // Show loading state
        const filesList = document.getElementById('files-list');
        filesList.innerHTML = '<li class="no-files">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå...</li>';
        
        // Load files for this subject with timeout
        try {
          await Promise.race([
            this.loadFilesForSubject(subject),
            new Promise((_, reject) => 
              setTimeout(() => reject(new Error('Timeout')), 10000)
            )
          ]);
        } catch (error) {
          console.error('Error in selectSubject:', error);
          filesList.innerHTML = '<li class="no-files">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå</li>';
        }
      }

      async loadFilesForSubject(subject) {
        try {
          console.log('Loading files for subject:', subject);
          console.log('API URL:', `${this.apiBaseUrl}/api/files/${this.currentYear}/${subject}`);
          
          const response = await fetch(`${this.apiBaseUrl}/api/files/${this.currentYear}/${subject}`, {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json'
            },
            cache: 'no-cache'
          });
          
          console.log('Response status:', response.status);
          console.log('Response headers:', response.headers);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('Response error:', errorText);
            throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('File tree data:', data);
          
          if (data.fileTree) {
            this.displayFileTree(data.fileTree);
          } else {
            console.error('No fileTree in response:', data);
            this.displayFileTree([]);
          }
        } catch (error) {
          console.error('Error loading files:', error);
          const filesList = document.getElementById('files-list');
          filesList.innerHTML = '<li class="no-files">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message + '</li>';
          this.addMessage('ai', '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
        }
      }

      displayFileTree(fileTree) {
        console.log('Displaying file tree:', fileTree);
        const filesList = document.getElementById('files-list');
        filesList.innerHTML = '';
        
        if (!fileTree || fileTree.length === 0) {
          console.log('No files found, showing placeholder');
          filesList.innerHTML = '<li class="no-files">‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô‡∏ß‡∏¥‡∏ä‡∏≤‡∏ô‡∏µ‡πâ</li>';
          return;
        }
        
        fileTree.forEach(item => {
          const treeItem = this.createTreeItem(item, 0);
          filesList.appendChild(treeItem);
        });
        
        console.log('File tree displayed successfully');
      }

      createTreeItem(item, depth) {
        const li = document.createElement('li');
        li.className = `tree-item ${item.type} depth-${depth}`;
        li.dataset.path = item.path;
        
        if (item.type === 'folder') {
          li.innerHTML = `
            <div class="tree-item-content" data-expanded="false">
              <span class="tree-toggle">‚ñ∂</span>
              <span class="tree-icon">üìÅ</span>
              <span class="tree-name">${item.name}</span>
            </div>
            <ul class="tree-children" style="display: none;"></ul>
          `;
          
          // Add click handler for folder expansion
          const content = li.querySelector('.tree-item-content');
          content.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log('Folder clicked:', item.name);
            this.toggleFolder(li, item);
          });
          
          // Add touch handler for iPad compatibility
          content.addEventListener('touchend', (e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log('Folder touched:', item.name);
            this.toggleFolder(li, item);
          });
          
          // Populate children
          if (item.children && item.children.length > 0) {
            const childrenUl = li.querySelector('.tree-children');
            item.children.forEach(child => {
              const childItem = this.createTreeItem(child, depth + 1);
              childrenUl.appendChild(childItem);
            });
          }
        } else {
          li.innerHTML = `
            <div class="tree-item-content">
              <span class="tree-icon">üìÑ</span>
              <span class="tree-name">${item.name}</span>
              <span class="tree-meta">${this.formatFileSize(item.size)}</span>
            </div>
          `;
          
          // Add click handler for file selection
          const content = li.querySelector('.tree-item-content');
          content.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log('File clicked:', item.name, 'Path:', item.path);
            this.selectFile(li, item);
          });
          
          // Add touch handler for iPad compatibility
          content.addEventListener('touchend', (e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log('File touched:', item.name, 'Path:', item.path);
            this.selectFile(li, item);
          });
        }
        
        return li;
      }

      toggleFolder(folderElement, folderData) {
        const content = folderElement.querySelector('.tree-item-content');
        const children = folderElement.querySelector('.tree-children');
        const toggle = folderElement.querySelector('.tree-toggle');
        const isExpanded = content.dataset.expanded === 'true';
        
        console.log('Toggling folder:', folderData.name, 'Currently expanded:', isExpanded);
        
        if (isExpanded) {
          children.style.display = 'none';
          toggle.textContent = '‚ñ∂';
          content.dataset.expanded = 'false';
          folderElement.classList.remove('expanded');
        } else {
          children.style.display = 'block';
          toggle.textContent = '‚ñº';
          content.dataset.expanded = 'true';
          folderElement.classList.add('expanded');
        }
      }

      clearFilesList() {
        const filesList = document.getElementById('files-list');
        filesList.innerHTML = '<li class="no-files">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏¥‡∏ä‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡πÑ‡∏ü‡∏•‡πå</li>';
      }

      async selectFile(fileItem, file) {
        // Remove active class from all files
        document.querySelectorAll('.tree-item').forEach(item => {
          item.classList.remove('active');
        });
        
        // Add active class to selected file
        fileItem.classList.add('active');
        
        // Update document title
        const docTitle = document.querySelector('.doc-title');
        if (docTitle) {
          docTitle.textContent = file.name;
        }
        
        // Load and display PDF
        await this.loadPDF(file);
      }

      async loadPDF(file) {
        try {
          this.showPDFLoading(true);
          
          const pdfUrl = `${this.apiBaseUrl}/api/pdf/${this.currentYear}/${this.currentSubject}?path=${encodeURIComponent(file.path)}`;
          
          console.log('Loading PDF from URL:', pdfUrl);
          
          // Load PDF using PDF.js
          const loadingTask = pdfjsLib.getDocument(pdfUrl);
          this.pdfDoc = await loadingTask.promise;
          
          this.totalPages = this.pdfDoc.numPages;
          this.currentPage = 1;
          this.currentPdf = file;
          
          await this.renderPage();
          this.hidePDFLoading();
          
        } catch (error) {
          console.error('Error loading PDF:', error);
          this.hidePDFLoading();
          this.addMessage('ai', '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î PDF ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
        }
      }

      async renderPage() {
        if (!this.pdfDoc) return;
        
        const canvas = document.getElementById('pdf-canvas');
        const context = canvas.getContext('2d');
        
        const page = await this.pdfDoc.getPage(this.currentPage);
        const viewport = page.getViewport({ scale: this.scale });
        
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        
        const renderContext = {
          canvasContext: context,
          viewport: viewport
        };
        
        await page.render(renderContext).promise;
        
        // Update UI controls
        this.updatePageInfo();
        this.updateZoomLevel();
        this.updateNavigationButtons();
      }

      async nextPage() {
        if (this.currentPage < this.totalPages) {
          this.currentPage++;
          await this.renderPage();
        }
      }

      async previousPage() {
        if (this.currentPage > 1) {
          this.currentPage--;
          await this.renderPage();
        }
      }

      async zoomIn() {
        this.scale = Math.min(this.scale + 0.25, 3.0);
        await this.renderPage();
      }

      async zoomOut() {
        this.scale = Math.max(this.scale - 0.25, 0.5);
        await this.renderPage();
      }

      updatePageInfo() {
        // Update page counter in toolbar if needed
        const pageInfo = document.querySelector('.page-info');
        if (pageInfo) {
          pageInfo.textContent = `${this.currentPage} / ${this.totalPages}`;
        }
        
        // Update page info in controls overlay
        const pageInfoOverlay = document.getElementById('page-info');
        if (pageInfoOverlay) {
          pageInfoOverlay.textContent = `${this.currentPage} / ${this.totalPages}`;
        }
      }

      updateZoomLevel() {
        const zoomLevel = document.getElementById('zoom-level');
        if (zoomLevel) {
          zoomLevel.textContent = `${Math.round(this.scale * 100)}%`;
        }
      }

      updateNavigationButtons() {
        const prevBtn = document.getElementById('prev-page-btn');
        const nextBtn = document.getElementById('next-page-btn');
        
        if (prevBtn) {
          prevBtn.disabled = this.currentPage <= 1;
          prevBtn.style.opacity = this.currentPage <= 1 ? '0.5' : '1';
        }
        
        if (nextBtn) {
          nextBtn.disabled = this.currentPage >= this.totalPages;
          nextBtn.style.opacity = this.currentPage >= this.totalPages ? '0.5' : '1';
        }
      }

      showPDFLoading(show) {
        const loading = document.getElementById('pdf-loading');
        const placeholder = document.getElementById('pdf-placeholder');
        const canvas = document.getElementById('pdf-canvas');
        
        if (show) {
          loading.style.display = 'flex';
          placeholder.style.display = 'none';
          canvas.style.display = 'none';
        } else {
          loading.style.display = 'none';
          placeholder.style.display = 'none';
          canvas.style.display = 'block';
        }
      }

      hidePDFLoading() {
        this.showPDFLoading(false);
      }

      setupPDFControls() {
        // Navigation buttons
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const fitWidthBtn = document.getElementById('fit-width-btn');
        const fitPageBtn = document.getElementById('fit-page-btn');

        if (prevPageBtn) prevPageBtn.addEventListener('click', () => this.previousPage());
        if (nextPageBtn) nextPageBtn.addEventListener('click', () => this.nextPage());
        if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => this.zoomOut());
        if (zoomInBtn) zoomInBtn.addEventListener('click', () => this.zoomIn());
        if (fitWidthBtn) fitWidthBtn.addEventListener('click', () => this.fitToWidth());
        if (fitPageBtn) fitPageBtn.addEventListener('click', () => this.fitToPage());
      }

      setupPDFGestures() {
        const pdfFrame = document.getElementById('pdf-frame');
        const pdfCanvas = document.getElementById('pdf-canvas');

        // Mouse events
        pdfFrame.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        pdfFrame.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        pdfFrame.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        pdfFrame.addEventListener('wheel', (e) => this.handleWheel(e));

        // Touch events
        pdfFrame.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
        pdfFrame.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        pdfFrame.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });

        // Prevent context menu on long press
        pdfFrame.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Sidebar swipe to close gesture
        this.setupSidebarGestures();
      }
      
      setupSidebarGestures() {
        const sidebar = document.querySelector('.sidebar');
        let touchStartX = 0;
        let touchStartY = 0;
        
        sidebar.addEventListener('touchstart', (e) => {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        }, { passive: true });
        
        sidebar.addEventListener('touchend', (e) => {
          const touchEndX = e.changedTouches[0].clientX;
          const touchEndY = e.changedTouches[0].clientY;
          const deltaX = touchEndX - touchStartX;
          const deltaY = touchEndY - touchStartY;
          
          // Swipe left to close sidebar (only if horizontal swipe is more significant than vertical)
          if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX < -50) {
            this.closeSidebar();
          }
        }, { passive: true });
      }

      handleMouseDown(e) {
        if (e.target.id === 'pdf-canvas') {
          this.isDragging = true;
          this.dragStart = { x: e.clientX, y: e.clientY };
          e.preventDefault();
        }
      }

      handleMouseMove(e) {
        if (this.isDragging) {
          e.preventDefault();
        }
      }

      handleMouseUp(e) {
        if (this.isDragging) {
          this.isDragging = false;
          e.preventDefault();
        }
      }

      handleWheel(e) {
        if (e.ctrlKey || e.metaKey) {
          // Zoom with Ctrl/Cmd + wheel
          e.preventDefault();
          const delta = e.deltaY > 0 ? -0.1 : 0.1;
          this.scale = Math.max(this.minScale, Math.min(this.maxScale, this.scale + delta));
          this.renderPage();
        }
      }

      handleTouchStart(e) {
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          this.touchStart = { x: touch.clientX, y: touch.clientY };
          this.lastTouchTime = Date.now();
        } else if (e.touches.length === 2) {
          // Two finger pinch
          e.preventDefault();
        }
      }

      handleTouchMove(e) {
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          const deltaX = touch.clientX - this.touchStart.x;
          const deltaY = touch.clientY - this.touchStart.y;
          
          // Swipe left/right for page navigation
          if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
            e.preventDefault();
            if (deltaX > 0) {
              this.previousPage();
            } else {
              this.nextPage();
            }
            this.touchStart = { x: touch.clientX, y: touch.clientY };
          }
        } else if (e.touches.length === 2) {
          // Pinch to zoom
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const distance = Math.sqrt(
            Math.pow(touch2.clientX - touch1.clientX, 2) +
            Math.pow(touch2.clientY - touch1.clientY, 2)
          );
          
          if (this.lastPinchDistance) {
            const scaleChange = distance / this.lastPinchDistance;
            this.scale = Math.max(this.minScale, Math.min(this.maxScale, this.scale * scaleChange));
            this.renderPage();
          }
          this.lastPinchDistance = distance;
        }
      }

      handleTouchEnd(e) {
        this.lastPinchDistance = null;
        
        // Double tap to fit to width
        if (e.touches.length === 0) {
          const now = Date.now();
          if (now - this.lastTouchTime < 300) {
            this.fitToWidth();
          }
        }
      }

      fitToWidth() {
        const pdfFrame = document.getElementById('pdf-frame');
        const frameWidth = pdfFrame.clientWidth - 40; // Account for padding
        const canvas = document.getElementById('pdf-canvas');
        
        if (this.pdfDoc && canvas) {
          const page = this.pdfDoc.getPage(this.currentPage);
          const viewport = page.getViewport({ scale: 1.0 });
          this.scale = frameWidth / viewport.width;
          this.scale = Math.max(this.minScale, Math.min(this.maxScale, this.scale));
          this.renderPage();
        }
      }

      fitToPage() {
        const pdfFrame = document.getElementById('pdf-frame');
        const frameWidth = pdfFrame.clientWidth - 40;
        const frameHeight = pdfFrame.clientHeight - 100; // Account for controls
        
        if (this.pdfDoc) {
          const page = this.pdfDoc.getPage(this.currentPage);
          const viewport = page.getViewport({ scale: 1.0 });
          const scaleX = frameWidth / viewport.width;
          const scaleY = frameHeight / viewport.height;
          this.scale = Math.min(scaleX, scaleY);
          this.scale = Math.max(this.minScale, Math.min(this.maxScale, this.scale));
          this.renderPage();
        }
      }

      closeSidebar() {
        const sidebarToggle = document.getElementById('toggle-sidebar');
        if (sidebarToggle) {
          sidebarToggle.checked = false;
        }
      }

      formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }

      // Utility method to format timestamps
      formatTimestamp(date) {
        return date.toLocaleTimeString('th-TH', {
          hour: '2-digit',
          minute: '2-digit'
        });
      }

      // Responsive Handlers
      setupResponsiveHandlers() {
        // Handle window resize
        window.addEventListener('resize', () => {
          this.handleResize();
        });

        // Handle orientation change
        window.addEventListener('orientationchange', () => {
          setTimeout(() => {
            this.handleResize();
          }, 100);
        });

        // Close overlays when clicking outside
        document.addEventListener('click', (e) => {
          this.handleOutsideClick(e);
        });

        // Handle escape key
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            this.handleEscapeKey();
          }
        });
      }

      handleResize() {
        const width = window.innerWidth;
        
        // Update writing tools position
        this.updateWritingToolsPosition();
        
        // Update zoom window if open
        if (this.zoomWindowActive) {
          this.updateZoomWindowLayout();
        }
        
        // Close overlays on very small screens
        if (width < 480) {
          this.closeOverlaysOnSmallScreen();
        }
      }

      updateWritingToolsPosition() {
        const writingTools = document.getElementById('writing-tools-overlay');
        if (!writingTools) return;

        const width = window.innerWidth;
        
        if (width < 480) {
          writingTools.style.minWidth = '280px';
          writingTools.style.padding = '8px';
        } else if (width < 860) {
          writingTools.style.minWidth = '320px';
          writingTools.style.padding = '12px';
        } else {
          writingTools.style.minWidth = '600px';
          writingTools.style.padding = '16px';
        }
      }

      updateZoomWindowLayout() {
        const zoomWindow = document.getElementById('zoom-window-overlay');
        const writingArea = document.getElementById('writing-area');
        const zoomMain = document.querySelector('.zoom-window-main');
        
        if (!zoomWindow || !writingArea || !zoomMain) return;

        const width = window.innerWidth;
        
        if (width < 480) {
          // Stack vertically on very small screens
          zoomMain.style.flexDirection = 'column';
          writingArea.style.width = '100%';
          writingArea.style.height = '200px';
          writingArea.style.borderLeft = 'none';
          writingArea.style.borderTop = '1px solid #e0e0e0';
        } else {
          // Side by side on larger screens
          zoomMain.style.flexDirection = 'row';
          writingArea.style.width = '400px';
          writingArea.style.height = 'auto';
          writingArea.style.borderLeft = '1px solid #e0e0e0';
          writingArea.style.borderTop = 'none';
        }
      }

      closeOverlaysOnSmallScreen() {
        const width = window.innerWidth;
        
        if (width < 480) {
          // Close chat if open
          const chatToggle = document.getElementById('toggle-chat');
          if (chatToggle && chatToggle.checked) {
            chatToggle.checked = false;
          }
          
          // Close sidebar if open
          const sidebarToggle = document.getElementById('toggle-sidebar');
          if (sidebarToggle && sidebarToggle.checked) {
            sidebarToggle.checked = false;
          }
        }
      }

      handleOutsideClick(e) {
        // Close sidebar if clicking outside
        const sidebar = document.querySelector('.sidebar');
        const sidebarToggle = document.getElementById('toggle-sidebar');
        
        if (sidebar && sidebarToggle && sidebarToggle.checked) {
          if (!sidebar.contains(e.target) && !e.target.closest('.sidebar')) {
            sidebarToggle.checked = false;
          }
        }

        // Close chat if clicking outside
        const chat = document.querySelector('.chat');
        const chatToggle = document.getElementById('toggle-chat');
        
        if (chat && chatToggle && chatToggle.checked) {
          if (!chat.contains(e.target) && !e.target.closest('.chat')) {
            chatToggle.checked = false;
          }
        }

        // Close zoom window if clicking outside
        if (this.zoomWindowActive) {
          const zoomWindow = document.getElementById('zoom-window-overlay');
          if (zoomWindow && !zoomWindow.contains(e.target)) {
            this.closeZoomWindow();
          }
        }
      }

      handleEscapeKey() {
        // Close zoom window
        if (this.zoomWindowActive) {
          this.closeZoomWindow();
          return;
        }

        // Close chat
        const chatToggle = document.getElementById('toggle-chat');
        if (chatToggle && chatToggle.checked) {
          chatToggle.checked = false;
          return;
        }

        // Close sidebar
        const sidebarToggle = document.getElementById('toggle-sidebar');
        if (sidebarToggle && sidebarToggle.checked) {
          sidebarToggle.checked = false;
          return;
        }
      }

      // Zoom Window Methods
      setupZoomWindowControls() {
        const zoomWindowBtn = document.getElementById('zoom-window-btn');
        const zoomWindowOverlay = document.getElementById('zoom-window-overlay');
        const zoomWindowClose = document.getElementById('zoom-window-close');
        const returnHeightSlider = document.getElementById('return-height');
        const returnHeightValue = document.getElementById('return-height-value');
        const autoAdvanceCheckbox = document.getElementById('auto-advance');

        if (zoomWindowBtn) {
          zoomWindowBtn.addEventListener('click', () => this.toggleZoomWindow());
        }

        if (zoomWindowClose) {
          zoomWindowClose.addEventListener('click', () => this.closeZoomWindow());
        }

        if (returnHeightSlider) {
          returnHeightSlider.addEventListener('input', (e) => {
            this.returnHeight = parseInt(e.target.value);
            returnHeightValue.textContent = `${this.returnHeight}px`;
          });
        }

        if (autoAdvanceCheckbox) {
          autoAdvanceCheckbox.addEventListener('change', (e) => {
            this.autoAdvance = e.target.checked;
          });
        }

        // Initialize zoom box references
        this.zoomBox = document.getElementById('zoom-box');
        this.zoomBoxContent = document.getElementById('zoom-box-content');
        
        if (this.zoomBox) {
          this.setupZoomBoxInteractions();
        }
      }

      toggleZoomWindow() {
        const zoomWindowOverlay = document.getElementById('zoom-window-overlay');
        const writingToolsOverlay = document.getElementById('writing-tools-overlay');
        
        if (this.zoomWindowActive) {
          this.closeZoomWindow();
        } else {
          this.openZoomWindow();
        }
      }

      openZoomWindow() {
        const zoomWindowOverlay = document.getElementById('zoom-window-overlay');
        const writingToolsOverlay = document.getElementById('writing-tools-overlay');
        
        if (zoomWindowOverlay) {
          zoomWindowOverlay.style.display = 'flex';
          this.zoomWindowActive = true;
          
          // Show writing tools
          if (writingToolsOverlay) {
            writingToolsOverlay.style.display = 'block';
          }
          
          // Update zoom box content with current PDF page
          this.updateZoomBoxContent();
        }
      }

      closeZoomWindow() {
        const zoomWindowOverlay = document.getElementById('zoom-window-overlay');
        const writingToolsOverlay = document.getElementById('writing-tools-overlay');
        
        if (zoomWindowOverlay) {
          zoomWindowOverlay.style.display = 'none';
          this.zoomWindowActive = false;
          
          // Hide writing tools
          if (writingToolsOverlay) {
            writingToolsOverlay.style.display = 'none';
          }
        }
      }

      setupZoomBoxInteractions() {
        if (!this.zoomBox) return;

        // Mouse events for dragging
        this.zoomBox.addEventListener('mousedown', (e) => this.handleZoomBoxMouseDown(e));
        document.addEventListener('mousemove', (e) => this.handleZoomBoxMouseMove(e));
        document.addEventListener('mouseup', (e) => this.handleZoomBoxMouseUp(e));

        // Touch events for mobile
        this.zoomBox.addEventListener('touchstart', (e) => this.handleZoomBoxTouchStart(e), { passive: false });
        document.addEventListener('touchmove', (e) => this.handleZoomBoxTouchMove(e), { passive: false });
        document.addEventListener('touchend', (e) => this.handleZoomBoxTouchEnd(e), { passive: false });

        // Resize handle events
        const resizeHandles = this.zoomBox.querySelectorAll('.resize-handle');
        resizeHandles.forEach(handle => {
          handle.addEventListener('mousedown', (e) => this.handleResizeStart(e));
          handle.addEventListener('touchstart', (e) => this.handleResizeStart(e), { passive: false });
        });
      }

      handleZoomBoxMouseDown(e) {
        if (e.target.classList.contains('resize-handle')) return;
        
        this.isDraggingZoomBox = true;
        this.dragStart = { x: e.clientX, y: e.clientY };
        e.preventDefault();
      }

      handleZoomBoxMouseMove(e) {
        if (!this.isDraggingZoomBox) return;
        
        const deltaX = e.clientX - this.dragStart.x;
        const deltaY = e.clientY - this.dragStart.y;
        
        this.zoomBoxPosition.x += deltaX;
        this.zoomBoxPosition.y += deltaY;
        
        this.updateZoomBoxPosition();
        this.dragStart = { x: e.clientX, y: e.clientY };
      }

      handleZoomBoxMouseUp(e) {
        this.isDraggingZoomBox = false;
        this.isResizingZoomBox = false;
        this.resizeDirection = null;
      }

      handleZoomBoxTouchStart(e) {
        if (e.target.classList.contains('resize-handle')) return;
        
        this.isDraggingZoomBox = true;
        const touch = e.touches[0];
        this.dragStart = { x: touch.clientX, y: touch.clientY };
        e.preventDefault();
      }

      handleZoomBoxTouchMove(e) {
        if (!this.isDraggingZoomBox) return;
        
        const touch = e.touches[0];
        const deltaX = touch.clientX - this.dragStart.x;
        const deltaY = touch.clientY - this.dragStart.y;
        
        this.zoomBoxPosition.x += deltaX;
        this.zoomBoxPosition.y += deltaY;
        
        this.updateZoomBoxPosition();
        this.dragStart = { x: touch.clientX, y: touch.clientY };
        e.preventDefault();
      }

      handleZoomBoxTouchEnd(e) {
        this.isDraggingZoomBox = false;
        this.isResizingZoomBox = false;
        this.resizeDirection = null;
      }

      handleResizeStart(e) {
        this.isResizingZoomBox = true;
        this.resizeDirection = e.target.dataset.direction;
        this.dragStart = { x: e.clientX || e.touches[0].clientX, y: e.clientY || e.touches[0].clientY };
        e.preventDefault();
      }

      updateZoomBoxPosition() {
        if (!this.zoomBox) return;
        
        const container = this.zoomBox.parentElement;
        const containerRect = container.getBoundingClientRect();
        
        // Constrain to container bounds
        this.zoomBoxPosition.x = Math.max(0, Math.min(this.zoomBoxPosition.x, containerRect.width - this.zoomBoxSize.width));
        this.zoomBoxPosition.y = Math.max(0, Math.min(this.zoomBoxPosition.y, containerRect.height - this.zoomBoxSize.height));
        
        this.zoomBox.style.left = `${this.zoomBoxPosition.x}px`;
        this.zoomBox.style.top = `${this.zoomBoxPosition.y}px`;
        this.zoomBox.style.transform = 'none';
      }

      updateZoomBoxContent() {
        if (!this.zoomBoxContent || !this.pdfDoc) return;
        
        // Create a canvas for the zoomed content
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        // Set canvas size to match zoom box
        canvas.width = this.zoomBoxSize.width;
        canvas.height = this.zoomBoxSize.height;
        
        // Calculate the source area from the main PDF canvas
        const mainCanvas = document.getElementById('pdf-canvas');
        if (mainCanvas) {
          const mainContext = mainCanvas.getContext('2d');
          const imageData = mainContext.getImageData(0, 0, mainCanvas.width, mainCanvas.height);
          
          // Draw the zoomed content
          context.putImageData(imageData, 0, 0);
        }
        
        // Clear and add the canvas
        this.zoomBoxContent.innerHTML = '';
        this.zoomBoxContent.appendChild(canvas);
        
        // Setup drawing on the zoom box content
        this.setupZoomBoxDrawing(canvas);
      }

      setupZoomBoxDrawing(canvas) {
        if (!canvas) return;
        
        const context = canvas.getContext('2d');
        
        // Mouse events for drawing
        canvas.addEventListener('mousedown', (e) => this.startDrawing(e, context));
        canvas.addEventListener('mousemove', (e) => this.draw(e, context));
        canvas.addEventListener('mouseup', () => this.stopDrawing());
        canvas.addEventListener('mouseout', () => this.stopDrawing());
        
        // Touch events for drawing
        canvas.addEventListener('touchstart', (e) => this.startDrawing(e, context), { passive: false });
        canvas.addEventListener('touchmove', (e) => this.draw(e, context), { passive: false });
        canvas.addEventListener('touchend', () => this.stopDrawing());
      }

      // Writing Tools Methods
      setupWritingToolsControls() {
        // Tool selection
        const penTool = document.getElementById('pen-tool');
        const highlighterTool = document.getElementById('highlighter-tool');
        const eraserTool = document.getElementById('eraser-tool');
        const lassoTool = document.getElementById('lasso-tool');
        const shapeTool = document.getElementById('shape-tool');
        const textTool = document.getElementById('text-tool');

        if (penTool) penTool.addEventListener('click', () => this.selectTool('pen'));
        if (highlighterTool) highlighterTool.addEventListener('click', () => this.selectTool('highlighter'));
        if (eraserTool) eraserTool.addEventListener('click', () => this.selectTool('eraser'));
        if (lassoTool) lassoTool.addEventListener('click', () => this.selectTool('lasso'));
        if (shapeTool) shapeTool.addEventListener('click', () => this.selectTool('shape'));
        if (textTool) textTool.addEventListener('click', () => this.selectTool('text'));

        // Color palette
        const colorOptions = document.querySelectorAll('.color-option');
        colorOptions.forEach(option => {
          option.addEventListener('click', (e) => {
            this.selectColor(e.target.dataset.color);
            this.updateColorSelection(e.target);
          });
        });

        // Size options
        const sizeOptions = document.querySelectorAll('.size-option');
        sizeOptions.forEach(option => {
          option.addEventListener('click', (e) => {
            this.penSize = parseInt(e.target.dataset.size);
            this.updateSizeSelection(e.target);
            this.updateSizeDisplay();
          });
        });

        // Sliders
        const penSizeSlider = document.getElementById('pen-size');
        const penOpacitySlider = document.getElementById('pen-opacity');
        const zoomFactorSlider = document.getElementById('zoom-factor');

        if (penSizeSlider) {
          penSizeSlider.addEventListener('input', (e) => {
            this.penSize = parseInt(e.target.value);
            this.updateSizeDisplay();
          });
        }

        if (penOpacitySlider) {
          penOpacitySlider.addEventListener('input', (e) => {
            this.penOpacity = parseFloat(e.target.value);
            this.updateOpacityDisplay();
          });
        }

        if (zoomFactorSlider) {
          zoomFactorSlider.addEventListener('input', (e) => {
            this.zoomFactor = parseInt(e.target.value) / 100;
            this.updateZoomFactorDisplay();
            this.updateZoomBoxContent();
          });
        }

        // Action buttons
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const clearBtn = document.getElementById('clear-btn');
        const saveBtn = document.getElementById('save-btn');

        if (undoBtn) undoBtn.addEventListener('click', () => this.undo());
        if (redoBtn) redoBtn.addEventListener('click', () => this.redo());
        if (clearBtn) clearBtn.addEventListener('click', () => this.clearCanvas());
        if (saveBtn) saveBtn.addEventListener('click', () => this.saveAnnotations());

        // Shape tools
        this.setupShapeTools();
        
        // Settings panel
        this.setupSettingsPanel();
      }

      setupShapeTools() {
        const shapeButtons = document.querySelectorAll('.shape-btn');
        shapeButtons.forEach(btn => {
          btn.addEventListener('click', (e) => {
            this.currentShape = e.target.dataset.shape;
            this.updateShapeSelection(e.target);
          });
        });
      }

      setupSettingsPanel() {
        const settingsBtn = document.getElementById('zoom-window-settings');
        const settingsPanel = document.getElementById('zoom-window-settings-panel');
        const pressureSensitivity = document.getElementById('pressure-sensitivity');
        const handwritingRecognition = document.getElementById('handwriting-recognition');

        if (settingsBtn && settingsPanel) {
          settingsBtn.addEventListener('click', () => {
            const isVisible = settingsPanel.style.display !== 'none';
            settingsPanel.style.display = isVisible ? 'none' : 'block';
          });
        }

        if (pressureSensitivity) {
          pressureSensitivity.addEventListener('change', (e) => {
            this.pressureSensitivity = e.target.checked;
          });
        }

        if (handwritingRecognition) {
          handwritingRecognition.addEventListener('change', (e) => {
            this.handwritingRecognition = e.target.checked;
          });
        }
      }

      selectTool(tool) {
        this.currentTool = tool;
        
        // Update active tool button
        document.querySelectorAll('.tool-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        
        const toolBtn = document.getElementById(`${tool}-tool`);
        if (toolBtn) {
          toolBtn.classList.add('active');
        }

        // Show/hide shape tools panel
        const shapePanel = document.getElementById('shape-tools-panel');
        if (shapePanel) {
          shapePanel.style.display = tool === 'shape' ? 'block' : 'none';
        }

        // Update cursor based on tool
        this.updateCursor(tool);
      }

      selectColor(color) {
        this.penColor = color;
      }

      updateColorSelection(selectedElement) {
        document.querySelectorAll('.color-option').forEach(option => {
          option.classList.remove('active');
        });
        selectedElement.classList.add('active');
      }

      updateSizeSelection(selectedElement) {
        document.querySelectorAll('.size-option').forEach(option => {
          option.classList.remove('active');
        });
        selectedElement.classList.add('active');
      }

      updateShapeSelection(selectedElement) {
        document.querySelectorAll('.shape-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        selectedElement.classList.add('active');
      }

      updateSizeDisplay() {
        const sizeValue = document.getElementById('pen-size-value');
        if (sizeValue) {
          sizeValue.textContent = `${this.penSize}px`;
        }
      }

      updateOpacityDisplay() {
        const opacityValue = document.getElementById('pen-opacity-value');
        if (opacityValue) {
          opacityValue.textContent = `${Math.round(this.penOpacity * 100)}%`;
        }
      }

      updateZoomFactorDisplay() {
        const zoomValue = document.getElementById('zoom-factor-value');
        const zoomIndicator = document.getElementById('zoom-level-indicator');
        const zoomPercent = Math.round(this.zoomFactor * 100);
        
        if (zoomValue) zoomValue.textContent = `${zoomPercent}%`;
        if (zoomIndicator) zoomIndicator.textContent = `${zoomPercent}%`;
      }

      updateCursor(tool) {
        const canvas = document.getElementById('writing-canvas');
        if (!canvas) return;

        const cursors = {
          pen: 'crosshair',
          highlighter: 'crosshair',
          eraser: 'grab',
          lasso: 'crosshair',
          shape: 'crosshair',
          text: 'text'
        };

        canvas.style.cursor = cursors[tool] || 'default';
      }

      startDrawing(e, context) {
        if (!this.zoomWindowActive) return;
        
        this.isDrawing = true;
        this.drawingPath = [];
        
        const rect = e.target.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        
        // Get pressure if available
        const pressure = this.getPressure(e);
        
        this.drawingPath.push({ x, y, pressure, timestamp: Date.now() });
        
        // Handle different tools
        switch (this.currentTool) {
          case 'pen':
            this.setupPenDrawing(context, pressure);
            break;
          case 'highlighter':
            this.setupHighlighterDrawing(context, pressure);
            break;
          case 'eraser':
            this.handleScribbleToErase(e, context);
            return;
          case 'lasso':
            this.handleCircleToLasso(e, context);
            return;
          case 'shape':
            this.startShapeDrawing(x, y);
            return;
          case 'text':
            this.startTextInput(x, y);
            return;
        }
        
        context.beginPath();
        context.moveTo(x, y);
        
        e.preventDefault();
      }

      getPressure(e) {
        if (this.pressureSensitivity && e.pressure !== undefined) {
          return Math.max(0.1, Math.min(1.0, e.pressure));
        }
        return 1.0;
      }

      setupPenDrawing(context, pressure = 1.0) {
        const size = this.penSize * pressure;
        context.strokeStyle = this.penColor;
        context.lineWidth = size;
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.globalCompositeOperation = 'source-over';
        context.globalAlpha = this.penOpacity;
      }

      setupHighlighterDrawing(context, pressure = 1.0) {
        const size = this.penSize * 3 * pressure; // Highlighter is thicker
        context.strokeStyle = this.penColor;
        context.lineWidth = size;
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.globalCompositeOperation = 'multiply'; // Highlighter effect
        context.globalAlpha = 0.3;
      }

      startShapeDrawing(x, y) {
        this.isDrawingShape = true;
        this.shapeStartPoint = { x, y };
      }

      startTextInput(x, y) {
        const text = prompt('Enter text:');
        if (text) {
          this.addTextToCanvas(text, x, y);
        }
      }

      addTextToCanvas(text, x, y) {
        const canvas = document.getElementById('writing-canvas');
        if (!canvas) return;

        const context = canvas.getContext('2d');
        context.font = `${this.penSize * 4}px Arial`;
        context.fillStyle = this.penColor;
        context.globalAlpha = this.penOpacity;
        context.fillText(text, x, y);

        // Save to history
        this.saveToHistory({
          type: 'text',
          text: text,
          x: x,
          y: y,
          color: this.penColor,
          size: this.penSize,
          opacity: this.penOpacity
        });
      }

      draw(e, context) {
        if (!this.isDrawing || !this.zoomWindowActive) return;
        
        const rect = e.target.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        
        this.drawingPath.push({ x, y });
        
        // Handle different tools
        switch (this.currentTool) {
          case 'pen':
            context.lineTo(x, y);
            context.stroke();
            break;
          case 'eraser':
            this.handleScribbleToErase(e, context);
            break;
          case 'lasso':
            this.handleCircleToLasso(e, context);
            break;
          case 'math':
            this.handleMathConversion(e, context);
            break;
        }
        
        // Check for auto-advance (only for pen tool)
        if (this.currentTool === 'pen' && this.autoAdvance && this.shouldAutoAdvance(x, y)) {
          this.autoAdvanceToNextLine();
        }
        
        e.preventDefault();
      }

      stopDrawing() {
        if (!this.isDrawing) return;
        
        this.isDrawing = false;
        
        // Save drawing to history
        if (this.drawingPath.length > 0) {
          this.saveToHistory({
            type: 'drawing',
            path: [...this.drawingPath],
            tool: this.currentTool,
            color: this.penColor,
            size: this.penSize,
            opacity: this.penOpacity
          });
        }
        
        this.drawingPath = [];
      }

      saveToHistory(action) {
        this.drawingHistory.push(action);
        this.undoStack.push(JSON.parse(JSON.stringify(this.drawingHistory)));
        this.redoStack = []; // Clear redo stack when new action is performed
        
        // Limit history size
        if (this.undoStack.length > 50) {
          this.undoStack.shift();
        }
      }

      undo() {
        if (this.undoStack.length > 1) {
          this.redoStack.push(this.undoStack.pop());
          this.drawingHistory = JSON.parse(JSON.stringify(this.undoStack[this.undoStack.length - 1]));
          this.redrawCanvas();
        }
      }

      redo() {
        if (this.redoStack.length > 0) {
          const action = this.redoStack.pop();
          this.undoStack.push(action);
          this.drawingHistory = JSON.parse(JSON.stringify(action));
          this.redrawCanvas();
        }
      }

      clearCanvas() {
        if (confirm('Are you sure you want to clear all annotations?')) {
          this.drawingHistory = [];
          this.undoStack = [];
          this.redoStack = [];
          this.redrawCanvas();
        }
      }

      saveAnnotations() {
        const canvas = document.getElementById('writing-canvas');
        if (!canvas) return;

        // Create download link
        const link = document.createElement('a');
        link.download = `annotations-${Date.now()}.png`;
        link.href = canvas.toDataURL();
        link.click();

        // Also save as JSON for later editing
        const annotations = {
          history: this.drawingHistory,
          metadata: {
            created: new Date().toISOString(),
            tool: this.currentTool,
            color: this.penColor,
            size: this.penSize
          }
        };

        const jsonBlob = new Blob([JSON.stringify(annotations, null, 2)], {
          type: 'application/json'
        });
        const jsonLink = document.createElement('a');
        jsonLink.download = `annotations-${Date.now()}.json`;
        jsonLink.href = URL.createObjectURL(jsonBlob);
        jsonLink.click();
      }

      shouldAutoAdvance(x, y) {
        // Check if drawing has exceeded the middle of the zoom box
        return y > this.zoomBoxSize.height / 2;
      }

      autoAdvanceToNextLine() {
        // Move the zoom box down by return height
        this.zoomBoxPosition.y += this.returnHeight;
        this.updateZoomBoxPosition();
        this.updateZoomBoxContent();
      }

      // Advanced Writing Features
      handleScribbleToErase(e, context) {
        if (this.currentTool !== 'eraser') return;
        
        const rect = e.target.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        
        // Use composite operation to erase
        context.globalCompositeOperation = 'destination-out';
        context.lineWidth = this.penSize * 2; // Make eraser larger
        context.lineCap = 'round';
        context.lineJoin = 'round';
        
        if (e.type === 'mousedown' || e.type === 'touchstart') {
          context.beginPath();
          context.moveTo(x, y);
        } else if (e.type === 'mousemove' || e.type === 'touchmove') {
          context.lineTo(x, y);
          context.stroke();
        }
        
        // Reset composite operation
        context.globalCompositeOperation = 'source-over';
      }

      handleCircleToLasso(e, context) {
        if (this.currentTool !== 'lasso') return;
        
        const rect = e.target.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        
        // Draw lasso selection
        context.strokeStyle = '#007AFF';
        context.lineWidth = 2;
        context.setLineDash([5, 5]);
        context.lineCap = 'round';
        
        if (e.type === 'mousedown' || e.type === 'touchstart') {
          this.lassoStart = { x, y };
          context.beginPath();
          context.moveTo(x, y);
        } else if (e.type === 'mousemove' || e.type === 'touchmove') {
          context.lineTo(x, y);
          context.stroke();
        } else if (e.type === 'mouseup' || e.type === 'touchend') {
          // Complete the lasso selection
          context.lineTo(this.lassoStart.x, this.lassoStart.y);
          context.stroke();
          context.setLineDash([]);
          
          // Select objects within the lasso area
          this.selectObjectsInLasso();
        }
      }

      selectObjectsInLasso() {
        // Find and select drawing objects within the lasso area
        const selectedObjects = [];
        
        this.drawingHistory.forEach((drawing, index) => {
          if (this.isObjectInLasso(drawing)) {
            selectedObjects.push(index);
          }
        });
        
        if (selectedObjects.length > 0) {
          this.showObjectMenu(selectedObjects);
        }
      }

      isObjectInLasso(drawing) {
        // Check if any point in the drawing path is within the lasso area
        return drawing.path.some(point => {
          return this.isPointInLasso(point);
        });
      }

      isPointInLasso(point) {
        // Simple point-in-polygon test for lasso selection
        // This is a simplified version - in a real implementation,
        // you'd want to use a more robust algorithm
        return true; // Placeholder
      }

      showObjectMenu(selectedObjects) {
        // Create context menu for selected objects
        const menu = document.createElement('div');
        menu.className = 'object-menu';
        menu.innerHTML = `
          <div class="menu-item" data-action="move">Move</div>
          <div class="menu-item" data-action="resize">Resize</div>
          <div class="menu-item" data-action="color">Change Color</div>
          <div class="menu-item" data-action="delete">Delete</div>
        `;
        
        // Position menu at cursor location
        menu.style.position = 'absolute';
        menu.style.left = this.lassoStart.x + 'px';
        menu.style.top = this.lassoStart.y + 'px';
        menu.style.background = 'white';
        menu.style.border = '1px solid #ccc';
        menu.style.borderRadius = '8px';
        menu.style.padding = '8px';
        menu.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
        menu.style.zIndex = '1000';
        
        // Add event listeners
        menu.addEventListener('click', (e) => {
          const action = e.target.dataset.action;
          this.handleObjectAction(action, selectedObjects);
          menu.remove();
        });
        
        // Add to document
        document.body.appendChild(menu);
        
        // Remove menu when clicking outside
        setTimeout(() => {
          document.addEventListener('click', () => menu.remove(), { once: true });
        }, 100);
      }

      handleObjectAction(action, selectedObjects) {
        switch (action) {
          case 'move':
            this.moveSelectedObjects(selectedObjects);
            break;
          case 'resize':
            this.resizeSelectedObjects(selectedObjects);
            break;
          case 'color':
            this.changeColorSelectedObjects(selectedObjects);
            break;
          case 'delete':
            this.deleteSelectedObjects(selectedObjects);
            break;
        }
      }

      moveSelectedObjects(selectedObjects) {
        // Implement object movement
        console.log('Moving objects:', selectedObjects);
      }

      resizeSelectedObjects(selectedObjects) {
        // Implement object resizing
        console.log('Resizing objects:', selectedObjects);
      }

      changeColorSelectedObjects(selectedObjects) {
        // Show color picker and update selected objects
        const colorPicker = document.createElement('input');
        colorPicker.type = 'color';
        colorPicker.addEventListener('change', (e) => {
          selectedObjects.forEach(index => {
            this.drawingHistory[index].color = e.target.value;
          });
          this.redrawCanvas();
        });
        colorPicker.click();
      }

      deleteSelectedObjects(selectedObjects) {
        // Remove selected objects from history
        selectedObjects.sort((a, b) => b - a); // Sort in descending order
        selectedObjects.forEach(index => {
          this.drawingHistory.splice(index, 1);
        });
        this.redrawCanvas();
      }

      redrawCanvas() {
        // Redraw the entire canvas with updated drawing history
        const canvas = document.getElementById('writing-canvas');
        if (!canvas) return;
        
        const context = canvas.getContext('2d');
        context.clearRect(0, 0, canvas.width, canvas.height);
        
        // Redraw all drawings
        this.drawingHistory.forEach(action => {
          if (action.type === 'drawing') {
            this.redrawDrawing(context, action);
          } else if (action.type === 'text') {
            this.redrawText(context, action);
          } else if (action.type === 'shape') {
            this.redrawShape(context, action);
          }
        });
      }

      redrawDrawing(context, action) {
        context.strokeStyle = action.color;
        context.lineWidth = action.size;
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.globalAlpha = action.opacity || 1;
        
        // Set composite operation based on tool
        if (action.tool === 'highlighter') {
          context.globalCompositeOperation = 'multiply';
        } else {
          context.globalCompositeOperation = 'source-over';
        }
        
        context.beginPath();
        action.path.forEach((point, index) => {
          const size = action.size * (point.pressure || 1);
          context.lineWidth = size;
          
          if (index === 0) {
            context.moveTo(point.x, point.y);
          } else {
            context.lineTo(point.x, point.y);
          }
        });
        context.stroke();
        
        // Reset composite operation
        context.globalCompositeOperation = 'source-over';
        context.globalAlpha = 1;
      }

      redrawText(context, action) {
        context.font = `${action.size * 4}px Arial`;
        context.fillStyle = action.color;
        context.globalAlpha = action.opacity || 1;
        context.fillText(action.text, action.x, action.y);
        context.globalAlpha = 1;
      }

      redrawShape(context, action) {
        context.strokeStyle = action.color;
        context.lineWidth = action.size;
        context.globalAlpha = action.opacity || 1;
        
        context.beginPath();
        this.drawShape(context, action.shape, action.startPoint, action.endPoint);
        context.stroke();
        context.globalAlpha = 1;
      }

      drawShape(context, shapeType, startPoint, endPoint) {
        const width = endPoint.x - startPoint.x;
        const height = endPoint.y - startPoint.y;
        
        switch (shapeType) {
          case 'rectangle':
            context.rect(startPoint.x, startPoint.y, width, height);
            break;
          case 'circle':
            const radius = Math.sqrt(width * width + height * height) / 2;
            context.arc(startPoint.x + width/2, startPoint.y + height/2, radius, 0, 2 * Math.PI);
            break;
          case 'line':
            context.moveTo(startPoint.x, startPoint.y);
            context.lineTo(endPoint.x, endPoint.y);
            break;
          case 'arrow':
            context.moveTo(startPoint.x, startPoint.y);
            context.lineTo(endPoint.x, endPoint.y);
            // Add arrowhead
            const angle = Math.atan2(height, width);
            const arrowLength = 20;
            context.lineTo(
              endPoint.x - arrowLength * Math.cos(angle - Math.PI / 6),
              endPoint.y - arrowLength * Math.sin(angle - Math.PI / 6)
            );
            context.moveTo(endPoint.x, endPoint.y);
            context.lineTo(
              endPoint.x - arrowLength * Math.cos(angle + Math.PI / 6),
              endPoint.y - arrowLength * Math.sin(angle + Math.PI / 6)
            );
            break;
        }
      }

      // Math Conversion Feature
      handleMathConversion(e, context) {
        if (this.currentTool !== 'math') return;
        
        // This would integrate with a math recognition API
        // For now, we'll show a placeholder
        const rect = e.target.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        
        // Show math conversion indicator
        context.fillStyle = '#007AFF';
        context.fillRect(x - 10, y - 10, 20, 20);
        
        // In a real implementation, you would:
        // 1. Capture the drawn math expression
        // 2. Send it to a math recognition service
        // 3. Convert it to LaTeX or formatted text
        // 4. Replace the handwritten math with formatted text
      }
    }

    // Initialize the app when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      new StudyPDFApp();
    });
  </script>
</body>
</html>
