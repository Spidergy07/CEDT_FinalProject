<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>PDF Study Platform ‚Äî RAG-ready</title>
  <link rel="stylesheet" href="styles.css?v=20250915-1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>
<body>
  <!-- JS-driven toggles (replaces checkbox hack) -->
  <div class="overlay" id="overlay" aria-hidden="true"></div>

  <header class="app-header">
    <div class="left">
      <button id="open-sidebar" class="icon-btn" type="button" aria-label="Toggle sidebar">‚ò∞</button>
      <a class="brand" href="#">Study<span>PDF</span></a>
    </div>
    <div class="center">
      <form class="search">
        <input type="search" placeholder="Search documents or topics‚Ä¶" aria-label="Search" />
      </form>
    </div>
    <div class="right">
      <button class="btn ghost">Login</button>
      <button id="open-chat" class="icon-btn" type="button" aria-label="Toggle chat">üí¨</button>
    </div>
  </header>

  <main class="app-shell">
    <!-- Sidebar: year navigation & files -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <h3>Academic Years</h3>
        <button class="close-sidebar-btn only-mobile" id="close-sidebar-btn" title="Close Sidebar">‚úï</button>
      </div>
      <div class="section">
        <ul class="year-list">
          <li class="year-item active" data-year="Year 1-1">
            <div class="year-header">
              <span class="year-icon">üìÅ</span>
              <span class="year-name">Year 1-1</span>
              <span class="year-toggle">‚ñº</span>
            </div>
            <ul class="subjects-list">
              <li class="subject-item" data-subject="Computer Programming">
                <span class="subject-icon">üíª</span>
                <span class="subject-name">Computer Programming</span>
              </li>
              <li class="subject-item" data-subject="Data Structures And Algorithms">
                <span class="subject-icon">üìä</span>
                <span class="subject-name">Data Structures And Algorithms</span>
              </li>
              <li class="subject-item" data-subject="Digital Computer Logic">
                <span class="subject-icon">üîß</span>
                <span class="subject-name">Digital Computer Logic</span>
              </li>
              <li class="subject-item" data-subject="Discrete Structures">
                <span class="subject-icon">üî¢</span>
                <span class="subject-name">Discrete Structures</span>
              </li>
              <li class="subject-item" data-subject="Introduction to CEDT">
                <span class="subject-icon">üéì</span>
                <span class="subject-name">Introduction to CEDT</span>
              </li>
            </ul>
          </li>
          <li class="year-item" data-year="Year 1-2">
            <div class="year-header">
              <span class="year-icon">üìÅ</span>
              <span class="year-name">Year 1-2</span>
              <span class="year-toggle">‚ñ∂</span>
            </div>
          </li>
          <li class="year-item" data-year="Year 2-1">
            <div class="year-header">
              <span class="year-icon">üìÅ</span>
              <span class="year-name">Year 2-1</span>
              <span class="year-toggle">‚ñ∂</span>
            </div>
          </li>
          <li class="year-item" data-year="Year 2-2">
            <div class="year-header">
              <span class="year-icon">üìÅ</span>
              <span class="year-name">Year 2-2</span>
              <span class="year-toggle">‚ñ∂</span>
            </div>
          </li>
        </ul>
      </div>
      <div class="section">
        <h3>Files</h3>
        <button class="btn" id="refresh-files-btn" style="margin-bottom: 10px; width: 100%; font-size: 12px;">üîÑ Refresh Files</button>
        <ul class="files" id="files-list">
          <!-- Files will be dynamically loaded here -->
        </ul>
      </div>
    </aside>
    <!-- Resizer between Sidebar and Viewer -->
    <div class="resizer resizer-left" id="resizer-left" role="separator" aria-label="Resize sidebar" aria-orientation="vertical"></div>

    <!-- Viewer: PDF area -->
    <section class="viewer">
      <div class="viewer-toolbar">
        <div class="toolbar-left">
          <strong class="doc-title">Lecture 01 ‚Äî Intro to C.pdf</strong>
        </div>
        <div class="toolbar-right">
          <button class="btn">Prev</button>
          <button class="btn">Next</button>
          <button class="btn">Zoom ‚àí</button>
          <button class="btn">Zoom +</button>
        </div>
      </div>

      <!-- PDF Viewer using PDF.js -->
      <div class="pdf-frame" id="pdf-frame">
        <div class="pdf-container" id="pdf-container">
          <canvas id="pdf-canvas"></canvas>
        </div>
        <div class="pdf-placeholder" id="pdf-placeholder">
          <div>
            <div class="ph-title">PDF Viewer</div>
            <p>Select a PDF file from the sidebar to view it here.</p>
            <p class="ph-note">Powered by PDF.js</p>
          </div>
        </div>
        <div class="pdf-loading" id="pdf-loading" style="display: none;">
          <div class="loading-spinner"></div>
          <p>Loading PDF...</p>
        </div>
        
        <!-- PDF Navigation Overlay -->
        <div class="pdf-nav-overlay" id="pdf-nav-overlay">
          <div class="pdf-nav-left" id="pdf-nav-left">
            <button class="nav-btn" id="prev-page-btn" title="Previous Page">‚Äπ</button>
          </div>
          <div class="pdf-nav-right" id="pdf-nav-right">
            <button class="nav-btn" id="next-page-btn" title="Next Page">‚Ä∫</button>
          </div>
        </div>
        
        <!-- PDF Controls Overlay -->
        <div class="pdf-controls-overlay" id="pdf-controls-overlay">
          <div class="pdf-controls">
            <button class="control-btn" id="zoom-out-btn" title="Zoom Out">‚àí</button>
            <span class="zoom-level" id="zoom-level">100%</span>
            <button class="control-btn" id="zoom-in-btn" title="Zoom In">+</button>
            <div class="page-info" id="page-info">1 / 1</div>
            <button class="control-btn" id="fit-width-btn" title="Fit Width">‚§¢</button>
            <button class="control-btn" id="fit-page-btn" title="Fit Page">‚§°</button>
            <button class="control-btn" id="zoom-window-btn" title="Zoom Window">üîç</button>
          </div>
        </div>
        
        <!-- Zoom Window Overlay -->
        <div class="zoom-window-overlay" id="zoom-window-overlay" style="display: none;">
          <div class="zoom-window-container">
            <div class="zoom-window-header">
              <div class="header-left">
                <h4>Zoom Window</h4>
                <div class="zoom-level-indicator">
                  <span id="zoom-level-indicator">200%</span>
                </div>
              </div>
              <div class="zoom-window-controls">
                <button class="zoom-window-btn" id="zoom-window-settings" title="Settings">‚öôÔ∏è</button>
                <button class="zoom-window-btn" id="zoom-window-close" title="Close">‚úï</button>
              </div>
            </div>
            
            <div class="zoom-window-main">
              <!-- PDF Preview Area -->
              <div class="pdf-preview-area" id="pdf-preview-area">
                <div class="pdf-preview-content" id="pdf-preview-content">
                  <!-- PDF preview will be rendered here -->
                </div>
                <div class="zoom-box" id="zoom-box">
                  <div class="zoom-box-content" id="zoom-box-content">
                    <!-- Zoomed content will be rendered here -->
                  </div>
                  <div class="zoom-box-resize-handles">
                    <div class="resize-handle resize-nw" data-direction="nw"></div>
                    <div class="resize-handle resize-ne" data-direction="ne"></div>
                    <div class="resize-handle resize-sw" data-direction="sw"></div>
                    <div class="resize-handle resize-se" data-direction="se"></div>
                    <div class="resize-handle resize-n" data-direction="n"></div>
                    <div class="resize-handle resize-s" data-direction="s"></div>
                    <div class="resize-handle resize-w" data-direction="w"></div>
                    <div class="resize-handle resize-e" data-direction="e"></div>
                  </div>
                </div>
              </div>
              
              <!-- Writing Area -->
              <div class="writing-area" id="writing-area">
                <div class="writing-canvas-container">
                  <canvas id="writing-canvas" width="400" height="300"></canvas>
                  <div class="writing-overlay" id="writing-overlay"></div>
                </div>
              </div>
            </div>
            
            <div class="zoom-window-settings-panel" id="zoom-window-settings-panel" style="display: none;">
              <div class="settings-section">
                <h5>Writing Settings</h5>
                <div class="setting-group">
                  <label for="return-height">Return Height:</label>
                  <input type="range" id="return-height" min="20" max="100" value="40" />
                  <span id="return-height-value">40px</span>
                </div>
                <div class="setting-group">
                  <label for="auto-advance">Auto Advance:</label>
                  <input type="checkbox" id="auto-advance" checked />
                </div>
                <div class="setting-group">
                  <label for="pressure-sensitivity">Pressure Sensitivity:</label>
                  <input type="checkbox" id="pressure-sensitivity" checked />
                </div>
                <div class="setting-group">
                  <label for="handwriting-recognition">Handwriting Recognition:</label>
                  <input type="checkbox" id="handwriting-recognition" checked />
                </div>
              </div>
              
              <div class="settings-section">
                <h5>Zoom Settings</h5>
                <div class="setting-group">
                  <label for="zoom-factor">Zoom Factor:</label>
                  <input type="range" id="zoom-factor" min="150" max="400" value="200" />
                  <span id="zoom-factor-value">200%</span>
                </div>
                <div class="setting-group">
                  <label for="zoom-box-size">Zoom Box Size:</label>
                  <select id="zoom-box-size">
                    <option value="small">Small (200x150)</option>
                    <option value="medium" selected>Medium (300x200)</option>
                    <option value="large">Large (400x300)</option>
                    <option value="custom">Custom</option>
                  </select>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Writing Tools Overlay -->
        <div class="writing-tools-overlay" id="writing-tools-overlay" style="display: none;">
          <div class="writing-tools">
            <!-- Tool Selection -->
            <div class="tool-group">
              <button class="tool-btn active" id="pen-tool" title="Pen">
                <div class="tool-icon">‚úèÔ∏è</div>
                <div class="tool-label">Pen</div>
              </button>
              <button class="tool-btn" id="highlighter-tool" title="Highlighter">
                <div class="tool-icon">üñçÔ∏è</div>
                <div class="tool-label">Highlighter</div>
              </button>
              <button class="tool-btn" id="eraser-tool" title="Eraser">
                <div class="tool-icon">üßπ</div>
                <div class="tool-label">Eraser</div>
              </button>
              <button class="tool-btn" id="lasso-tool" title="Lasso">
                <div class="tool-icon">ü™ù</div>
                <div class="tool-label">Lasso</div>
              </button>
              <button class="tool-btn" id="shape-tool" title="Shapes">
                <div class="tool-icon">‚¨ú</div>
                <div class="tool-label">Shapes</div>
              </button>
              <button class="tool-btn" id="text-tool" title="Text">
                <div class="tool-icon">T</div>
                <div class="tool-label">Text</div>
              </button>
            </div>
            
            <!-- Tool Settings -->
            <div class="tool-settings">
              <div class="setting-row">
                <label for="pen-color">Color:</label>
                <div class="color-palette">
                  <div class="color-option active" data-color="#000000" style="background: #000000"></div>
                  <div class="color-option" data-color="#FF0000" style="background: #FF0000"></div>
                  <div class="color-option" data-color="#00FF00" style="background: #00FF00"></div>
                  <div class="color-option" data-color="#0000FF" style="background: #0000FF"></div>
                  <div class="color-option" data-color="#FFFF00" style="background: #FFFF00"></div>
                  <div class="color-option" data-color="#FF00FF" style="background: #FF00FF"></div>
                  <div class="color-option" data-color="#00FFFF" style="background: #00FFFF"></div>
                  <div class="color-option" data-color="#FFA500" style="background: #FFA500"></div>
                  <input type="color" id="pen-color" value="#000000" title="Custom Color" />
                </div>
              </div>
              
              <div class="setting-row">
                <label for="pen-size">Size:</label>
                <div class="size-options">
                  <div class="size-option active" data-size="1">1</div>
                  <div class="size-option" data-size="2">2</div>
                  <div class="size-option" data-size="3">3</div>
                  <div class="size-option" data-size="5">5</div>
                  <div class="size-option" data-size="8">8</div>
                  <div class="size-option" data-size="12">12</div>
                </div>
                <input type="range" id="pen-size" min="1" max="20" value="3" title="Pen Size" />
                <span id="pen-size-value">3px</span>
              </div>
              
              <div class="setting-row">
                <label for="pen-opacity">Opacity:</label>
                <input type="range" id="pen-opacity" min="0.1" max="1" step="0.1" value="1" title="Opacity" />
                <span id="pen-opacity-value">100%</span>
              </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="action-buttons">
              <button class="action-btn" id="undo-btn" title="Undo">‚Ü∂</button>
              <button class="action-btn" id="redo-btn" title="Redo">‚Ü∑</button>
              <button class="action-btn" id="clear-btn" title="Clear">üóëÔ∏è</button>
              <button class="action-btn" id="save-btn" title="Save">üíæ</button>
            </div>
          </div>
        </div>
        
        <!-- Shape Tools Panel -->
        <div class="shape-tools-panel" id="shape-tools-panel" style="display: none;">
          <div class="shape-options">
            <button class="shape-btn active" data-shape="rectangle" title="Rectangle">‚¨ú</button>
            <button class="shape-btn" data-shape="circle" title="Circle">‚≠ï</button>
            <button class="shape-btn" data-shape="line" title="Line">üìè</button>
            <button class="shape-btn" data-shape="arrow" title="Arrow">‚û°Ô∏è</button>
            <button class="shape-btn" data-shape="star" title="Star">‚≠ê</button>
            <button class="shape-btn" data-shape="heart" title="Heart">‚ù§Ô∏è</button>
          </div>
        </div>
      </div>
    </section>

    <!-- Resizer between Viewer and Chat -->
    <div class="resizer resizer-right" id="resizer-right" role="separator" aria-label="Resize chat" aria-orientation="vertical"></div>

    <!-- Chat/Q&A panel -->
    <aside class="chat">
      <div class="chat-header">
        <h3>‡∏ñ‡∏≤‡∏° TA Tohtoh</h3>
        <button class="close-chat-btn only-mobile" id="close-chat-btn" title="Close Chat">‚úï</button>
      </div>
      <div class="chat-body">
        <!-- Messages will be dynamically added here -->
        <button class="scroll-to-bottom" id="scroll-to-bottom" title="Scroll to bottom">
          ‚Üì
        </button>
      </div>
      <form class="chat-input" action="#" method="get">
        <input type="text" placeholder="‡∏ñ‡∏≤‡∏°‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô..." aria-label="Ask about this PDF" />
        <button class="btn primary" type="submit">Send</button>
      </form>
    </aside>
  </main>

  <footer class="app-footer">
    <div>¬© 2025 StudyPDF ‚Ä¢ Demo UI</div>
    <nav class="foot-links">
      <a href="#">Privacy</a>
      <a href="#">Terms</a>
      <a href="#">Help</a>
    </nav>
  </footer>

  <script>
    // Study PDF Platform - Frontend JavaScript
    class StudyPDFApp {
      constructor() {
        this.apiBaseUrl = 'http://localhost:3000';
        this.chatHistory = [];
        this.isLoading = false;
        this.currentYear = 'Year 1-1';
        this.currentSubject = null;
        this.currentPdf = null;
        this.currentFileTree = [];
        this.pdfDoc = null;
        this.currentPage = 1;
        this.totalPages = 0;
        this.scale = 1.0;
        this.minScale = 0.5;
        this.maxScale = 3.0;
        this.isDragging = false;
        this.dragStart = { x: 0, y: 0 };
        this.touchStart = { x: 0, y: 0 };
        this.lastTouchTime = 0;
        // Panning state for zoomed canvas
        this.isPanning = false;
        this.panStart = { x: 0, y: 0 };
        this.scrollStart = { left: 0, top: 0 };
        
        // Zoom Window properties
        this.zoomWindowActive = false;
        this.zoomBox = null;
        this.zoomBoxContent = null;
        this.zoomBoxPosition = { x: 0, y: 0 };
        this.zoomBoxSize = { width: 300, height: 200 };
        this.returnHeight = 40;
        this.autoAdvance = true;
        this.isDraggingZoomBox = false;
        this.isResizingZoomBox = false;
        this.resizeDirection = null;
        this.dragStart = { x: 0, y: 0 };
        
        // Writing tools properties
        this.currentTool = 'pen';
        this.penColor = '#000000';
        this.penSize = 3;
        this.penOpacity = 1;
        this.isDrawing = false;
        this.drawingPath = [];
        this.drawingHistory = [];
        this.currentDrawing = null;
        this.undoStack = [];
        this.redoStack = [];
        this.pressureSensitivity = true;
        this.handwritingRecognition = true;
        this.zoomFactor = 2.0;
        this.currentShape = 'rectangle';
        this.isDrawingShape = false;
        this.shapeStartPoint = null;
        this.layers = [];
        this.currentLayer = 0;

        // Panel resize state
        this.isResizingPanels = false;
        this.activeResizer = null; // 'left' | 'right' | null
        this.resizeStartX = 0;
        this.startSidebarWidth = 280;
        this.startChatWidth = 360;
        
        this.init();
      }

      init() {
        this.setupEventListeners();
        this.loadInitialState();
        // Ensure overlay aligns with header height on load
        this.updateOverlayTop();
      }

      setupEventListeners() {
        // Prevent iOS Safari from zooming on double-tap
        document.addEventListener('touchstart', function(e) {
          if (e.touches.length > 1) {
            e.preventDefault();
          }
        }, { passive: false });

        // Handle responsive behavior
        this.setupResponsiveHandlers();
        // Desktop panel resizers
        this.setupResizablePanels();

        // Mobile panel toggles (hamburger/chat)
        const openSidebarBtn = document.getElementById('open-sidebar');
        if (openSidebarBtn) {
          openSidebarBtn.addEventListener('click', () => {
            if (window.innerWidth <= 1024) {
              if (document.body.classList.contains('sidebar-open')) {
                this.closeSidebar();
              } else {
                this.openSidebar();
              }
            } else {
              document.body.classList.toggle('sidebar-hidden');
              this.adjustViewerAfterLayoutChange();
            }
          });
        }

        const openChatBtn = document.getElementById('open-chat');
        if (openChatBtn) {
          openChatBtn.addEventListener('click', () => {
            if (window.innerWidth <= 1024) {
              if (document.body.classList.contains('chat-open')) {
                this.closeChat();
              } else {
                this.openChat();
              }
            } else {
              document.body.classList.toggle('chat-hidden');
              this.adjustViewerAfterLayoutChange();
            }
          });
        }

        // Backdrop overlay
        const overlay = document.getElementById('overlay');
        if (overlay) {
          overlay.addEventListener('click', () => {
            this.closeSidebar();
            this.closeChat();
          });
        }

        // Chat form submission
        const chatForm = document.querySelector('.chat-input');
        if (chatForm) {
          chatForm.addEventListener('submit', (e) => {
            e.preventDefault();
            this.handleChatSubmit();
          });
        }

        // No global toggle for sources; indicator with popover handled per message

        // Chat scroll functionality
        const chatBody = document.querySelector('.chat-body');
        const scrollToBottomBtn = document.querySelector('.scroll-to-bottom');
        
        if (chatBody && scrollToBottomBtn) {
          // Monitor scroll position
          chatBody.addEventListener('scroll', () => {
            this.checkScrollPosition();
          });
          
          // Scroll to bottom button click
          scrollToBottomBtn.addEventListener('click', () => {
            this.scrollToBottom();
          });
        }

        // Search form submission
        const searchForm = document.querySelector('.search');
        if (searchForm) {
          searchForm.addEventListener('submit', (e) => {
            e.preventDefault();
            this.handleSearchSubmit();
          });
        }

        // Year selection
        const yearItems = document.querySelectorAll('.year-item');
        yearItems.forEach(item => {
          // Add both click and touch events for better iPad compatibility
          item.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            this.selectYear(item);
          });
          
          item.addEventListener('touchend', (e) => {
            e.stopPropagation();
            e.preventDefault();
            this.selectYear(item);
          });
        });

        // Subject selection
        const subjectItems = document.querySelectorAll('.subject-item');
        subjectItems.forEach(item => {
          // Add both click and touch events for better iPad compatibility
          item.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log('Subject clicked:', item.dataset.subject);
            this.selectSubject(item);
          });
          
          item.addEventListener('touchend', (e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log('Subject touched:', item.dataset.subject);
            this.selectSubject(item);
          });
          
          // Add touchstart to prevent default behavior
          item.addEventListener('touchstart', (e) => {
            e.stopPropagation();
          }, { passive: true });
        });

        // PDF navigation buttons (old toolbar)
        const prevBtn = document.querySelector('.toolbar-right .btn:nth-child(1)');
        const nextBtn = document.querySelector('.toolbar-right .btn:nth-child(2)');
        const zoomOutBtn = document.querySelector('.toolbar-right .btn:nth-child(3)');
        const zoomInBtn = document.querySelector('.toolbar-right .btn:nth-child(4)');

        if (prevBtn) prevBtn.addEventListener('click', () => this.previousPage());
        if (nextBtn) nextBtn.addEventListener('click', () => this.nextPage());
        if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => this.zoomOut());
        if (zoomInBtn) zoomInBtn.addEventListener('click', () => this.zoomIn());

        // New PDF controls
        this.setupPDFControls();
        
        // Touch and mouse gestures
        this.setupPDFGestures();
        
        // Zoom window controls
        this.setupZoomWindowControls();
        
        // Writing tools controls
        this.setupWritingToolsControls();
        
        // Refresh files button
        const refreshBtn = document.getElementById('refresh-files-btn');
        if (refreshBtn) {
          refreshBtn.addEventListener('click', () => {
            if (this.currentSubject) {
              console.log('Manually refreshing files for:', this.currentSubject);
              this.loadFilesForSubject(this.currentSubject);
            } else {
              console.log('No subject selected');
            }
          });
        }
        
        // Close sidebar button
        const closeSidebarBtn = document.getElementById('close-sidebar-btn');
        if (closeSidebarBtn) {
          closeSidebarBtn.addEventListener('click', () => {
            this.closeSidebar();
          });
        }

        // Close chat button (mobile)
        const closeChatBtn = document.getElementById('close-chat-btn');
        if (closeChatBtn) {
          closeChatBtn.addEventListener('click', () => {
            this.closeChat();
          });
        }

        // Tap chat header to close on mobile/tablet
        const chatHeader = document.querySelector('.chat-header');
        if (chatHeader) {
          chatHeader.addEventListener('click', () => {
            if (window.innerWidth <= 1024 && document.body.classList.contains('chat-open')) {
              this.closeChat();
            }
          });
        }
      }

      loadInitialState() {
        // Add initial AI message
        this.addMessage('ai', '‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ! ‡∏ú‡∏°‡∏Ñ‡∏∑‡∏≠ TA Tohtoh ‡∏ú‡∏π‡πâ‡∏ä‡πà‡∏ß‡∏¢‡∏™‡∏≠‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ñ‡∏≤‡∏°‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢ ‡∏ú‡∏°‡∏à‡∏∞‡∏ä‡πà‡∏ß‡∏¢‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏•‡∏∞‡∏ï‡∏≠‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì');
      }

      async handleChatSubmit() {
        const input = document.querySelector('.chat-input input');
        const question = input.value.trim();
        
        if (!question || this.isLoading) return;

        // Add user message
        this.addMessage('user', question);
        input.value = '';

        // Show loading state
        this.setLoading(true);
        this.showTypingIndicator();

        try {
          // Call the search-and-answer API
          const response = await fetch(`${this.apiBaseUrl}/search-and-answer-multi`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              question: question,
              topK: 6
            })
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();

          // Display the answer
          this.hideTypingIndicator();
          this.addMessage('ai', data.answer.answer);
          // Add sources (images used) under the AI message
          if (data && data.answer && Array.isArray(data.answer.imagePaths) && data.answer.imagePaths.length) {
            this.addSources(data.answer.imagePaths);
          } else if (data && data.search && Array.isArray(data.search.topResults)) {
            const fallback = data.search.topResults.map(r => r.imagePath).filter(Boolean);
            if (fallback.length) this.addSources(fallback);
          }
          
          // Update chat history
          this.chatHistory.push({
            question: question,
            answer: data.answer.answer,
            timestamp: new Date()
          });

        } catch (error) {
          console.error('Error calling API:', error);
          this.hideTypingIndicator();
          this.addMessage('ai', '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢ ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏° ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
        } finally {
          this.setLoading(false);
        }
      }

      // Render chips into a container
      renderSourceChips(container, unique) {
        const title = document.createElement('div');
        title.className = 'sources-title';
        title.textContent = `‡πÅ‡∏´‡∏•‡πà‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏≤ (${unique.length})`;
        container.appendChild(title);

        unique.slice(0, 6).forEach((imgPath) => {
          const info = this.parseImageInfo(imgPath);
          const chip = document.createElement('button');
          chip.type = 'button';
          chip.className = 'source-chip';
          chip.title = `${info.base}${info.page ? ` ‚Äî page ${info.page}` : ''}`;
          chip.innerHTML = `
            <span class="icon">üñºÔ∏è</span>
            <span class="label">${info.baseShort}</span>
            ${info.page ? `<span class="page-badge">p.${info.page}</span>` : ''}
          `;
          chip.addEventListener('click', () => this.openPdfFromImagePath(imgPath));
          container.appendChild(chip);
        });
      }

      // Add clickable source chips under the last AI message
      addSources(imagePaths) {
        try {
          const chatBody = document.querySelector('.chat-body');
          const lastAi = Array.from(chatBody.querySelectorAll('.msg.ai')).pop();
          if (!lastAi) return;
          const bubble = lastAi.querySelector('.bubble');
          if (!bubble) return;

          // Unique sources
          const unique = Array.from(new Set(imagePaths));

          // Compact indicator with count
          const indicator = document.createElement('button');
          indicator.type = 'button';
          indicator.className = 'sources-indicator';
          indicator.title = '‡πÅ‡∏´‡∏•‡πà‡∏á‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á';
          indicator.innerHTML = `<span class=\"icon\">üìé</span><span class=\"count\">${unique.length}</span>`;

          // Popover with chips
          const popover = document.createElement('div');
          popover.className = 'sources-popover';
          this.renderSourceChips(popover, unique);

          bubble.appendChild(indicator);
          bubble.appendChild(popover);

          // Hover open/close
          let hoverTimer;
          const openPopover = () => popover.classList.add('open');
          const closePopover = () => popover.classList.remove('open');
          indicator.addEventListener('mouseenter', () => { clearTimeout(hoverTimer); openPopover(); });
          indicator.addEventListener('mouseleave', () => { hoverTimer = setTimeout(closePopover, 120); });
          popover.addEventListener('mouseenter', () => { clearTimeout(hoverTimer); openPopover(); });
          popover.addEventListener('mouseleave', () => { hoverTimer = setTimeout(closePopover, 120); });

          // Click toggle (for touch devices)
          indicator.addEventListener('click', (e) => { e.stopPropagation(); popover.classList.toggle('open'); });
          document.addEventListener('click', (e) => { if (!popover.contains(e.target) && !indicator.contains(e.target)) closePopover(); });

          this.scrollToBottom();
        } catch (e) {
          console.warn('addSources failed:', e);
        }
      }

      // Parse info from an image path like: .../Some_Doc-333-12345/Some_Doc-333-12345_page_7.png
      parseImageInfo(imagePath) {
        const filename = (imagePath.split('/').pop() || '').replace(/%20/g, ' ');
        const dir = (imagePath.split('/').slice(-2, -1)[0] || '').replace(/%20/g, ' ');
        const pageMatch = filename.match(/_page_(\d+)\.png$/i);
        const page = pageMatch ? parseInt(pageMatch[1], 10) : null;
        // base candidate from directory name (more stable than file name)
        let base = dir || filename.replace(/_page_\d+\.png$/i, '');
        // strip trailing -digits-digits if present
        base = base.replace(/-\d+-\d+$/, '');
        const baseShort = base.length > 36 ? base.slice(0, 33) + '‚Ä¶' : base;
        return { filename, dir, page, base, baseShort };
      }

      // Try to open the PDF that produced this image and jump to page
      async openPdfFromImagePath(imagePath) {
        const info = this.parseImageInfo(imagePath);

        // Helper: normalize text for fuzzy match
        const normalize = (s) => (s || '').toLowerCase().replace(/[\s_\-]+/g, '');
        const needle = normalize(info.base);

        // Helper: search recursively inside a file tree
        const findPdfInTree = (nodes) => {
          for (const n of nodes || []) {
            if (n.type === 'folder') {
              const found = findPdfInTree(n.children || []);
              if (found) return found;
            } else if (n.type === 'file') {
              const nameNoExt = n.name.replace(/\.pdf$/i, '');
              const hay = normalize(nameNoExt);
              if (hay.includes(needle) || needle.includes(hay)) return n;
            }
          }
          return null;
        };

        // Helper: ensure UI selection reflects the subject
        const activateSubjectUI = (subject) => {
          // Activate current year panel
          const yearItems = Array.from(document.querySelectorAll('.year-item'));
          yearItems.forEach((el) => el.classList.remove('active'));
          const yearEl = document.querySelector(`.year-item[data-year="${this.currentYear}"]`);
          if (yearEl) yearEl.classList.add('active');
          // Toggle subject highlight
          document.querySelectorAll('.subject-item').forEach(el => el.classList.remove('active'));
          const subjEl = document.querySelector(`.subject-item[data-subject="${subject}"]`);
          if (subjEl) subjEl.classList.add('active');
        };

        // Ensure we have a current year (default already set in constructor)
        if (!this.currentYear) this.currentYear = 'Year 1-1';

        // Step 1: Try current subject first (if any)
        let found = null;
        let foundSubject = this.currentSubject || null;

        if (this.currentSubject) {
          if (!Array.isArray(this.currentFileTree) || this.currentFileTree.length === 0) {
            await this.loadFilesForSubject(this.currentSubject);
          }
          found = findPdfInTree(this.currentFileTree || []);
        }

        // Step 2: If not found or no subject selected, search across all subjects in current year
        if (!found) {
          // Build subject list under the active/current year
          const yearEl = document.querySelector(`.year-item[data-year="${this.currentYear}"]`);
          const subjectEls = yearEl ? Array.from(yearEl.querySelectorAll('.subject-item')) : [];
          const subjects = subjectEls.map(el => el.getAttribute('data-subject'));

          for (const subject of subjects) {
            if (subject === this.currentSubject) continue;
            try {
              await this.loadFilesForSubject(subject);
              const candidate = findPdfInTree(this.currentFileTree || []);
              if (candidate) {
                found = candidate;
                foundSubject = subject;
                break;
              }
            } catch (e) {
              console.warn('Failed loading files for subject', subject, e);
            }
          }
        }

        if (!found) {
          this.addMessage('ai', `‡∏´‡∏≤‡πÑ‡∏ü‡∏•‡πå PDF ‡∏ó‡∏µ‡πà‡∏™‡∏≠‡∏î‡∏Ñ‡∏•‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö "${info.base}" ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÉ‡∏ô‡∏õ‡∏µ ${this.currentYear}${this.currentSubject ? ` (‡∏ß‡∏¥‡∏ä‡∏≤ ${this.currentSubject})` : ''}`);
          return;
        }

        // Switch current subject if needed so viewer endpoints resolve correctly
        if (foundSubject && foundSubject !== this.currentSubject) {
          this.currentSubject = foundSubject;
          activateSubjectUI(foundSubject);
        }

        // Load PDF if different from current, then jump to page
        const ensureLoaded = async () => {
          const currName = this.currentPdf?.name;
          if (!currName || currName !== found.name) {
            await this.loadPDF(found);
          }
        };

        try {
          await ensureLoaded();
          if (info.page) {
            this.currentPage = Math.min(Math.max(1, info.page), this.totalPages || info.page);
            await this.renderPage();
          }
          // Focus viewer panel on desktop
          const viewer = document.getElementById('pdf-frame');
          if (viewer) viewer.scrollIntoView({ behavior: 'smooth', block: 'center' });
        } catch (e) {
          console.error('openPdfFromImagePath error:', e);
          this.addMessage('ai', '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏õ‡∏¥‡∏î‡∏´‡∏ô‡πâ‡∏≤ PDF ‡∏ó‡∏µ‡πà‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡πÑ‡∏î‡πâ');
        }
      }

      async handleSearchSubmit() {
        const input = document.querySelector('.search input');
        const query = input.value.trim();
        
        if (!query) return;

        // For now, just add the search query to chat
        this.addMessage('user', `‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤: ${query}`);
        
        // You can implement search functionality here
        this.addMessage('ai', '‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏ô‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï');
        
        input.value = '';
      }

      // Typing indicator (animated)
      showTypingIndicator() {
        // Avoid duplicates
        if (this.typingEl) return;
        const chatBody = document.querySelector('.chat-body');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'msg ai loading typing';
        const bubbleDiv = document.createElement('div');
        bubbleDiv.className = 'bubble';
        bubbleDiv.textContent = 'TA Tohtoh ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏¥‡∏°‡∏û‡πå';
        messageDiv.appendChild(bubbleDiv);
        chatBody.appendChild(messageDiv);
        this.scrollToBottom();
        this.typingEl = messageDiv;
      }

      hideTypingIndicator() {
        if (this.typingEl && this.typingEl.parentNode) {
          this.typingEl.parentNode.removeChild(this.typingEl);
        }
        this.typingEl = null;
      }

      addMessage(sender, content) {
        const chatBody = document.querySelector('.chat-body');
        const messageDiv = document.createElement('div');
        messageDiv.className = `msg ${sender}`;
        
        const bubbleDiv = document.createElement('div');
        bubbleDiv.className = 'bubble';
        // Render richer, readable content (Markdown-lite + line breaks)
        bubbleDiv.innerHTML = this.renderRichText(content);
        
        messageDiv.appendChild(bubbleDiv);
        chatBody.appendChild(messageDiv);
        
        // Smooth scroll to bottom
        this.scrollToBottom();
      }

      // Safely render simple Markdown and structure for readability
      renderRichText(text) {
        if (!text || typeof text !== 'string') return '';

        // Escape HTML
        let escaped = text
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;');

        // Preserve fenced code blocks ```code```
        const codeBlocks = [];
        escaped = escaped.replace(/```[\s\S]*?```/g, (block) => {
          const inner = block.slice(3, -3); // remove backticks
          const placeholder = `__CODEBLOCK_${codeBlocks.length}__`;
          codeBlocks.push(inner.trim());
          return placeholder;
        });

        // Headings (#, ##, ###) at line start
        escaped = escaped
          .replace(/^###\s+(.+)$/gm, '<h3>$1</h3>')
          .replace(/^##\s+(.+)$/gm, '<h2>$1</h2>')
          .replace(/^#\s+(.+)$/gm, '<h1>$1</h1>');

        // Bold and italic
        escaped = escaped
          .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
          .replace(/\*(.+?)\*/g, '<em>$1</em>')
          .replace(/`([^`]+)`/g, '<code>$1</code>');

        // Build lists and paragraphs
        const lines = escaped.split(/\n+/);
        const htmlParts = [];
        let listMode = null; // 'ul' | 'ol'
        let listItems = [];

        const flushList = () => {
          if (listMode && listItems.length) {
            htmlParts.push(`<${listMode}>` + listItems.map(li => `<li>${li}</li>`).join('') + `</${listMode}>`);
          }
          listMode = null;
          listItems = [];
        };

        for (const rawLine of lines) {
          const line = rawLine.trimEnd();
          if (!line.trim()) { // paragraph break
            flushList();
            continue;
          }

          // Ordered list: 1. item
          const olMatch = line.match(/^\d+\.\s+(.*)$/);
          if (olMatch) {
            const item = olMatch[1];
            if (listMode && listMode !== 'ol') flushList();
            listMode = 'ol';
            listItems.push(item);
            continue;
          }

          // Unordered list: - item or ‚Ä¢ item
          const ulMatch = line.match(/^(?:[-\u2022])\s+(.*)$/);
          if (ulMatch) {
            const item = ulMatch[1];
            if (listMode && listMode !== 'ul') flushList();
            listMode = 'ul';
            listItems.push(item);
            continue;
          }

          // Not a list line
          flushList();
          // Convert remaining single line to paragraph or keep as is if already a heading
          if (/^<h[1-3]>/.test(line)) {
            htmlParts.push(line);
          } else {
            htmlParts.push(`<p>${line}</p>`);
          }
        }
        flushList();

        let html = htmlParts.join('\n');

        // Restore fenced code blocks
        html = html.replace(/__CODEBLOCK_(\d+)__/g, (_, idx) => {
          const code = (codeBlocks[Number(idx)] || '').replace(/\n/g, '\n');
          return `<pre><code>${code}</code></pre>`;
        });

        return html;
      }

      scrollToBottom() {
        const chatBody = document.querySelector('.chat-body');
        chatBody.scrollTo({
          top: chatBody.scrollHeight,
          behavior: 'smooth'
        });
      }

      checkScrollPosition() {
        const chatBody = document.querySelector('.chat-body');
        const scrollBtn = document.querySelector('.scroll-to-bottom');
        
        if (!scrollBtn) return;
        
        const isNearBottom = chatBody.scrollTop + chatBody.clientHeight >= chatBody.scrollHeight - 50;
        
        if (isNearBottom) {
          scrollBtn.style.display = 'none';
        } else {
          scrollBtn.style.display = 'flex';
        }
      }

      setLoading(loading) {
        this.isLoading = loading;
        const submitBtn = document.querySelector('.chat-input button');
        const input = document.querySelector('.chat-input input');
        
        if (loading) {
          submitBtn.textContent = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...';
          submitBtn.disabled = true;
          input.disabled = true;
        } else {
          submitBtn.textContent = 'Send';
          submitBtn.disabled = false;
          input.disabled = false;
        }
      }

      async selectYear(yearItem) {
        const year = yearItem.dataset.year;
        
        // Toggle year expansion
        if (yearItem.classList.contains('active')) {
          yearItem.classList.remove('active');
          return;
        }
        
        // Remove active class from all years
        document.querySelectorAll('.year-item').forEach(item => {
          item.classList.remove('active');
        });
        
        // Add active class to selected year
        yearItem.classList.add('active');
        this.currentYear = year;
        
        // Clear files list
        this.clearFilesList();
      }

      async selectSubject(subjectItem) {
        const subject = subjectItem.dataset.subject;
        
        console.log('Selecting subject:', subject);
        
        // Remove active class from all subjects
        document.querySelectorAll('.subject-item').forEach(item => {
          item.classList.remove('active');
        });
        
        // Add active class to selected subject
        subjectItem.classList.add('active');
        this.currentSubject = subject;
        
        // Show loading state
        const filesList = document.getElementById('files-list');
        filesList.innerHTML = '<li class="no-files">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå...</li>';
        
        // Load files for this subject with timeout
        try {
          await Promise.race([
            this.loadFilesForSubject(subject),
            new Promise((_, reject) => 
              setTimeout(() => reject(new Error('Timeout')), 10000)
            )
          ]);
        } catch (error) {
          console.error('Error in selectSubject:', error);
          filesList.innerHTML = '<li class="no-files">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå</li>';
        }
      }

      async loadFilesForSubject(subject) {
        try {
          console.log('Loading files for subject:', subject);
          console.log('API URL:', `${this.apiBaseUrl}/api/files/${this.currentYear}/${subject}`);
          
          const response = await fetch(`${this.apiBaseUrl}/api/files/${this.currentYear}/${subject}`, {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json'
            },
            cache: 'no-cache'
          });
          
          console.log('Response status:', response.status);
          console.log('Response headers:', response.headers);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('Response error:', errorText);
            throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('File tree data:', data);
          
          if (data.fileTree) {
            this.displayFileTree(data.fileTree);
          } else {
            console.error('No fileTree in response:', data);
            this.displayFileTree([]);
          }
        } catch (error) {
          console.error('Error loading files:', error);
          const filesList = document.getElementById('files-list');
          filesList.innerHTML = '<li class="no-files">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message + '</li>';
          this.addMessage('ai', '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
        }
      }

      displayFileTree(fileTree) {
        console.log('Displaying file tree:', fileTree);
        // cache for lookup when resolving sources
        this.currentFileTree = Array.isArray(fileTree) ? fileTree : [];
        const filesList = document.getElementById('files-list');
        filesList.innerHTML = '';
        
        if (!fileTree || fileTree.length === 0) {
          console.log('No files found, showing placeholder');
          filesList.innerHTML = '<li class="no-files">‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô‡∏ß‡∏¥‡∏ä‡∏≤‡∏ô‡∏µ‡πâ</li>';
          return;
        }
        
        fileTree.forEach(item => {
          const treeItem = this.createTreeItem(item, 0);
          filesList.appendChild(treeItem);
        });
        
        console.log('File tree displayed successfully');
      }

      createTreeItem(item, depth) {
        const li = document.createElement('li');
        li.className = `tree-item ${item.type} depth-${depth}`;
        li.dataset.path = item.path;
        
        if (item.type === 'folder') {
          li.innerHTML = `
            <div class="tree-item-content" data-expanded="false">
              <span class="tree-toggle">‚ñ∂</span>
              <span class="tree-icon">üìÅ</span>
              <span class="tree-name">${item.name}</span>
            </div>
            <ul class="tree-children" style="display: none;"></ul>
          `;
          
          // Add click handler for folder expansion
          const content = li.querySelector('.tree-item-content');
          content.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log('Folder clicked:', item.name);
            this.toggleFolder(li, item);
          });
          
          // Add touch handler for iPad compatibility
          content.addEventListener('touchend', (e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log('Folder touched:', item.name);
            this.toggleFolder(li, item);
          });
          
          // Populate children
          if (item.children && item.children.length > 0) {
            const childrenUl = li.querySelector('.tree-children');
            item.children.forEach(child => {
              const childItem = this.createTreeItem(child, depth + 1);
              childrenUl.appendChild(childItem);
            });
          }
        } else {
          li.innerHTML = `
            <div class="tree-item-content">
              <span class="tree-icon">üìÑ</span>
              <span class="tree-name">${item.name}</span>
              <span class="tree-meta">${this.formatFileSize(item.size)}</span>
            </div>
          `;
          
          // Add click handler for file selection
          const content = li.querySelector('.tree-item-content');
          content.addEventListener('click', (e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log('File clicked:', item.name, 'Path:', item.path);
            this.selectFile(li, item);
          });
          
          // Add touch handler for iPad compatibility
          content.addEventListener('touchend', (e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log('File touched:', item.name, 'Path:', item.path);
            this.selectFile(li, item);
          });
        }
        
        return li;
      }

      toggleFolder(folderElement, folderData) {
        const content = folderElement.querySelector('.tree-item-content');
        const children = folderElement.querySelector('.tree-children');
        const toggle = folderElement.querySelector('.tree-toggle');
        const isExpanded = content.dataset.expanded === 'true';
        
        console.log('Toggling folder:', folderData.name, 'Currently expanded:', isExpanded);
        
        if (isExpanded) {
          children.style.display = 'none';
          toggle.textContent = '‚ñ∂';
          content.dataset.expanded = 'false';
          folderElement.classList.remove('expanded');
        } else {
          children.style.display = 'block';
          toggle.textContent = '‚ñº';
          content.dataset.expanded = 'true';
          folderElement.classList.add('expanded');
        }
      }

      clearFilesList() {
        const filesList = document.getElementById('files-list');
        filesList.innerHTML = '<li class="no-files">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏¥‡∏ä‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡πÑ‡∏ü‡∏•‡πå</li>';
      }

      async selectFile(fileItem, file) {
        // Remove active class from all files
        document.querySelectorAll('.tree-item').forEach(item => {
          item.classList.remove('active');
        });
        
        // Add active class to selected file
        fileItem.classList.add('active');
        
        // On mobile/tablet, close the sidebar to give viewer full width
        if (window.innerWidth <= 1024) {
          this.closeSidebar();
        }

        // Update document title
        const docTitle = document.querySelector('.doc-title');
        if (docTitle) {
          docTitle.textContent = file.name;
        }
        
        // Load and display PDF
        await this.loadPDF(file);
      }

      async loadPDF(file) {
        try {
          this.showPDFLoading(true);
          
          const pdfUrl = `${this.apiBaseUrl}/api/pdf/${this.currentYear}/${this.currentSubject}?path=${encodeURIComponent(file.path)}`;
          
          console.log('Loading PDF from URL:', pdfUrl);
          
          // Load PDF using PDF.js
          const loadingTask = pdfjsLib.getDocument(pdfUrl);
          this.pdfDoc = await loadingTask.promise;
          
          this.totalPages = this.pdfDoc.numPages;
          this.currentPage = 1;
          this.currentPdf = file;
          
          await this.renderPage();
          // Start with a comfortable default zoom
          await this.fitToWidth();
          this.hidePDFLoading();
          
        } catch (error) {
          console.error('Error loading PDF:', error);
          this.hidePDFLoading();
          this.addMessage('ai', '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î PDF ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á');
        }
      }

      async renderPage() {
        if (!this.pdfDoc) return;
        
        const canvas = document.getElementById('pdf-canvas');
        const context = canvas.getContext('2d');
        
        const page = await this.pdfDoc.getPage(this.currentPage);
        const viewport = page.getViewport({ scale: this.scale });
        
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        // Keep CSS size in sync so zoom reflects intrinsic canvas size
        canvas.style.width = `${viewport.width}px`;
        canvas.style.height = `${viewport.height}px`;
        
        const renderContext = {
          canvasContext: context,
          viewport: viewport
        };
        
        await page.render(renderContext).promise;
        
        // Update UI controls
        this.updatePageInfo();
        this.updateZoomLevel();
        this.updateNavigationButtons();

        // Update pannability cursor based on overflow
        const container = document.getElementById('pdf-container');
        if (container) {
          const canPan = (container.scrollWidth > container.clientWidth) || (container.scrollHeight > container.clientHeight);
          container.style.cursor = canPan ? 'grab' : 'default';
        }
      }

      async nextPage() {
        if (this.currentPage < this.totalPages) {
          this.currentPage++;
          await this.renderPage();
        }
      }

      async previousPage() {
        if (this.currentPage > 1) {
          this.currentPage--;
          await this.renderPage();
        }
      }

      async zoomIn() {
        this.scale = Math.min(this.scale + 0.25, 3.0);
        await this.renderPage();
      }

      async zoomOut() {
        this.scale = Math.max(this.scale - 0.25, 0.5);
        await this.renderPage();
      }

      updatePageInfo() {
        // Update page counter in toolbar if needed
        const pageInfo = document.querySelector('.page-info');
        if (pageInfo) {
          pageInfo.textContent = `${this.currentPage} / ${this.totalPages}`;
        }
        
        // Update page info in controls overlay
        const pageInfoOverlay = document.getElementById('page-info');
        if (pageInfoOverlay) {
          pageInfoOverlay.textContent = `${this.currentPage} / ${this.totalPages}`;
        }
      }

      updateZoomLevel() {
        const zoomLevel = document.getElementById('zoom-level');
        if (zoomLevel) {
          zoomLevel.textContent = `${Math.round(this.scale * 100)}%`;
        }
      }

      updateNavigationButtons() {
        const prevBtn = document.getElementById('prev-page-btn');
        const nextBtn = document.getElementById('next-page-btn');
        
        if (prevBtn) {
          prevBtn.disabled = this.currentPage <= 1;
          prevBtn.style.opacity = this.currentPage <= 1 ? '0.5' : '1';
        }
        
        if (nextBtn) {
          nextBtn.disabled = this.currentPage >= this.totalPages;
          nextBtn.style.opacity = this.currentPage >= this.totalPages ? '0.5' : '1';
        }
      }

      showPDFLoading(show) {
        const loading = document.getElementById('pdf-loading');
        const placeholder = document.getElementById('pdf-placeholder');
        const canvas = document.getElementById('pdf-canvas');
        
        if (show) {
          loading.style.display = 'flex';
          placeholder.style.display = 'none';
          canvas.style.display = 'none';
        } else {
          loading.style.display = 'none';
          placeholder.style.display = 'none';
          canvas.style.display = 'block';
        }
      }

      hidePDFLoading() {
        this.showPDFLoading(false);
      }

      setupPDFControls() {
        // Navigation buttons
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const fitWidthBtn = document.getElementById('fit-width-btn');
        const fitPageBtn = document.getElementById('fit-page-btn');

        if (prevPageBtn) prevPageBtn.addEventListener('click', () => this.previousPage());
        if (nextPageBtn) nextPageBtn.addEventListener('click', () => this.nextPage());
        if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => this.zoomOut());
        if (zoomInBtn) zoomInBtn.addEventListener('click', () => this.zoomIn());
        if (fitWidthBtn) fitWidthBtn.addEventListener('click', () => this.fitToWidth());
        if (fitPageBtn) fitPageBtn.addEventListener('click', () => this.fitToPage());
      }

      setupPDFGestures() {
        const pdfFrame = document.getElementById('pdf-frame');
        const pdfCanvas = document.getElementById('pdf-canvas');

        // Mouse events
        pdfFrame.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        pdfFrame.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        pdfFrame.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        pdfFrame.addEventListener('wheel', (e) => this.handleWheel(e));

        // Touch events
        pdfFrame.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
        pdfFrame.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        pdfFrame.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });

        // Prevent context menu on long press
        pdfFrame.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Sidebar swipe to close gesture
        this.setupSidebarGestures();
      }
      
      setupSidebarGestures() {
        const sidebar = document.querySelector('.sidebar');
        let touchStartX = 0;
        let touchStartY = 0;
        
        sidebar.addEventListener('touchstart', (e) => {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        }, { passive: true });
        
        sidebar.addEventListener('touchend', (e) => {
          const touchEndX = e.changedTouches[0].clientX;
          const touchEndY = e.changedTouches[0].clientY;
          const deltaX = touchEndX - touchStartX;
          const deltaY = touchEndY - touchStartY;
          
          // Swipe left to close sidebar (only if horizontal swipe is more significant than vertical)
          if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX < -50) {
            this.closeSidebar();
          }
        }, { passive: true });
      }

      handleMouseDown(e) {
        const container = document.getElementById('pdf-container');
        if (!container) return;
        const within = container.contains(e.target);
        if (within) {
          // Begin panning
          this.isPanning = true;
          this.panStart = { x: e.clientX, y: e.clientY };
          this.scrollStart = { left: container.scrollLeft, top: container.scrollTop };
          container.style.cursor = 'grabbing';
          e.preventDefault();
        }
      }

      handleMouseMove(e) {
        if (this.isPanning) {
          const container = document.getElementById('pdf-container');
          if (!container) return;
          const dx = e.clientX - this.panStart.x;
          const dy = e.clientY - this.panStart.y;
          container.scrollLeft = this.scrollStart.left - dx;
          container.scrollTop = this.scrollStart.top - dy;
          e.preventDefault();
        }
      }

      handleMouseUp(e) {
        if (this.isPanning) {
          const container = document.getElementById('pdf-container');
          if (container) container.style.cursor = 'grab';
          this.isPanning = false;
          e.preventDefault();
        }
      }

      handleWheel(e) {
        if (e.ctrlKey || e.metaKey) {
          // Zoom with Ctrl/Cmd + wheel
          e.preventDefault();
          const delta = e.deltaY > 0 ? -0.1 : 0.1;
          this.scale = Math.max(this.minScale, Math.min(this.maxScale, this.scale + delta));
          this.renderPage();
        }
      }

      handleTouchStart(e) {
        const container = document.getElementById('pdf-container');
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          this.touchStart = { x: touch.clientX, y: touch.clientY };
          this.lastTouchTime = Date.now();
          if (container) {
            const canPan = (container.scrollWidth > container.clientWidth) || (container.scrollHeight > container.clientHeight);
            if (canPan) {
              this.isPanning = true;
              this.panStart = { x: touch.clientX, y: touch.clientY };
              this.scrollStart = { left: container.scrollLeft, top: container.scrollTop };
            }
          }
        } else if (e.touches.length === 2) {
          // Two finger pinch
          e.preventDefault();
        }
      }

      handleTouchMove(e) {
        const container = document.getElementById('pdf-container');
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          if (this.isPanning && container) {
            const dx = touch.clientX - this.panStart.x;
            const dy = touch.clientY - this.panStart.y;
            container.scrollLeft = this.scrollStart.left - dx;
            container.scrollTop = this.scrollStart.top - dy;
            e.preventDefault();
            return;
          }
          // If not panning, allow swipe to change page
          const deltaX = touch.clientX - this.touchStart.x;
          const deltaY = touch.clientY - this.touchStart.y;
          if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
            e.preventDefault();
            if (deltaX > 0) {
              this.previousPage();
            } else {
              this.nextPage();
            }
            this.touchStart = { x: touch.clientX, y: touch.clientY };
          }
        } else if (e.touches.length === 2) {
          // Pinch to zoom
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const distance = Math.sqrt(
            Math.pow(touch2.clientX - touch1.clientX, 2) +
            Math.pow(touch2.clientY - touch1.clientY, 2)
          );
          
          if (this.lastPinchDistance) {
            const scaleChange = distance / this.lastPinchDistance;
            this.scale = Math.max(this.minScale, Math.min(this.maxScale, this.scale * scaleChange));
            this.renderPage();
          }
          this.lastPinchDistance = distance;
        }
      }

      handleTouchEnd(e) {
        this.lastPinchDistance = null;
        if (this.isPanning) {
          this.isPanning = false;
        }
        
        // Double tap to fit to width
        if (e.touches.length === 0) {
          const now = Date.now();
          if (now - this.lastTouchTime < 300) {
            this.fitToWidth();
          }
        }
      }

      async fitToWidth() {
        const pdfFrame = document.getElementById('pdf-frame');
        const frameWidth = pdfFrame.clientWidth - 40; // Account for padding
        const canvas = document.getElementById('pdf-canvas');
        
        if (this.pdfDoc && canvas) {
          const page = await this.pdfDoc.getPage(this.currentPage);
          const viewport = page.getViewport({ scale: 1.0 });
          this.scale = frameWidth / viewport.width;
          this.scale = Math.max(this.minScale, Math.min(this.maxScale, this.scale));
          await this.renderPage();
        }
      }

      async fitToPage() {
        const pdfFrame = document.getElementById('pdf-frame');
        const frameWidth = pdfFrame.clientWidth - 40;
        const frameHeight = pdfFrame.clientHeight - 100; // Account for controls
        
        if (this.pdfDoc) {
          const page = await this.pdfDoc.getPage(this.currentPage);
          const viewport = page.getViewport({ scale: 1.0 });
          const scaleX = frameWidth / viewport.width;
          const scaleY = frameHeight / viewport.height;
          this.scale = Math.min(scaleX, scaleY);
          this.scale = Math.max(this.minScale, Math.min(this.maxScale, this.scale));
          await this.renderPage();
        }
      }

      openSidebar() {
        document.body.classList.add('sidebar-open');
        document.body.classList.remove('chat-open');
        this.updateOverlayTop();
      }

      closeSidebar() {
        document.body.classList.remove('sidebar-open');
      }

      openChat() {
        document.body.classList.add('chat-open');
        document.body.classList.remove('sidebar-open');
        this.updateOverlayTop();
      }

      closeChat() {
        document.body.classList.remove('chat-open');
      }

      formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }

      // Utility method to format timestamps
      formatTimestamp(date) {
        return date.toLocaleTimeString('th-TH', {
          hour: '2-digit',
          minute: '2-digit'
        });
      }

      // Responsive Handlers
      setupResponsiveHandlers() {
        // Handle window resize
        window.addEventListener('resize', () => {
          this.handleResize();
          this.updateOverlayTop();
          this.updateResizerAvailability();
        });

        // Handle orientation change
        window.addEventListener('orientationchange', () => {
          setTimeout(() => {
            this.handleResize();
          }, 100);
        });

        // Close overlays when clicking outside
        document.addEventListener('click', (e) => {
          this.handleOutsideClick(e);
        });

        // Handle escape key
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            this.handleEscapeKey();
          }
        });

        // Panel conflict management handled by openSidebar/openChat
      }

      handleResize() {
        const width = window.innerWidth;
        
        // Update writing tools position
        this.updateWritingToolsPosition();
        
        // Update zoom window if open
        if (this.zoomWindowActive) {
          this.updateZoomWindowLayout();
        }
        
        // Close overlays on very small screens
        if (width < 480) {
          this.closeOverlaysOnSmallScreen();
        }

        // When returning to desktop, ensure panels are reset
        if (width > 1024) {
          document.body.classList.remove('sidebar-open');
          document.body.classList.remove('chat-open');
        }
        // Ensure resizers enabled/disabled appropriately
        this.updateResizerAvailability();
      }

      updateWritingToolsPosition() {
        const writingTools = document.getElementById('writing-tools-overlay');
        if (!writingTools) return;

        const width = window.innerWidth;
        
        if (width < 480) {
          writingTools.style.minWidth = '280px';
          writingTools.style.padding = '8px';
        } else if (width < 860) {
          writingTools.style.minWidth = '320px';
          writingTools.style.padding = '12px';
        } else {
          writingTools.style.minWidth = '600px';
          writingTools.style.padding = '16px';
        }
      }

      updateZoomWindowLayout() {
        const zoomWindow = document.getElementById('zoom-window-overlay');
        const writingArea = document.getElementById('writing-area');
        const zoomMain = document.querySelector('.zoom-window-main');
        
        if (!zoomWindow || !writingArea || !zoomMain) return;

        const width = window.innerWidth;
        
        if (width < 480) {
          // Stack vertically on very small screens
          zoomMain.style.flexDirection = 'column';
          writingArea.style.width = '100%';
          writingArea.style.height = '200px';
          writingArea.style.borderLeft = 'none';
          writingArea.style.borderTop = '1px solid #e0e0e0';
        } else {
          // Side by side on larger screens
          zoomMain.style.flexDirection = 'row';
          writingArea.style.width = '400px';
          writingArea.style.height = 'auto';
          writingArea.style.borderLeft = '1px solid #e0e0e0';
          writingArea.style.borderTop = 'none';
        }
      }

      adjustViewerAfterLayoutChange() {
        // Refit PDF to new available width on desktop panel toggles
        try {
          if (this.pdfDoc) {
            this.fitToWidth();
          }
        } catch (e) {
          console.warn('adjustViewerAfterLayoutChange failed:', e);
        }
        // Sync resizers when layout toggles
        this.updateResizerAvailability();
      }

      updateOverlayTop() {
        const overlay = document.getElementById('overlay');
        const header = document.querySelector('.app-header');
        if (overlay && header) {
          overlay.style.top = `${header.offsetHeight}px`;
        }
      }

      // =====================
      // Resizable Panels (Desktop)
      // =====================
      setupResizablePanels() {
        // Initialize CSS variables from localStorage if available
        const root = document.documentElement;
        const savedSidebar = localStorage.getItem('sidebarWidth');
        const savedChat = localStorage.getItem('chatWidth');
        if (savedSidebar) root.style.setProperty('--sidebar-width', `${parseInt(savedSidebar, 10)}px`);
        if (savedChat) root.style.setProperty('--chat-width', `${parseInt(savedChat, 10)}px`);

        // Cache starting values
        const computed = getComputedStyle(root);
        this.startSidebarWidth = parseInt(computed.getPropertyValue('--sidebar-width')) || 280;
        this.startChatWidth = parseInt(computed.getPropertyValue('--chat-width')) || 360;

        const left = document.getElementById('resizer-left');
        const right = document.getElementById('resizer-right');
        this.leftResizer = left;
        this.rightResizer = right;

        if (left) {
          left.addEventListener('mousedown', (e) => this.beginPanelResize(e, 'left'));
          left.addEventListener('touchstart', (e) => this.beginPanelResize(e, 'left'), { passive: true });
        }
        if (right) {
          right.addEventListener('mousedown', (e) => this.beginPanelResize(e, 'right'));
          right.addEventListener('touchstart', (e) => this.beginPanelResize(e, 'right'), { passive: true });
        }

        // Global listeners
        document.addEventListener('mousemove', (e) => this.handlePanelResize(e));
        document.addEventListener('mouseup', () => this.endPanelResize());
        document.addEventListener('touchmove', (e) => this.handlePanelResize(e), { passive: false });
        document.addEventListener('touchend', () => this.endPanelResize());

        this.updateResizerAvailability();
      }

      updateResizerAvailability() {
        const desktop = window.innerWidth > 1024;
        const left = this.leftResizer;
        const right = this.rightResizer;

        if (!left || !right) return;

        if (!desktop) {
          left.style.display = 'none';
          right.style.display = 'none';
          this.isResizingPanels = false;
          this.activeResizer = null;
          return;
        }

        // Hide resizer next to any hidden panel
        const sidebarHidden = document.body.classList.contains('sidebar-hidden');
        const chatHidden = document.body.classList.contains('chat-hidden');

        left.style.display = sidebarHidden ? 'none' : 'block';
        right.style.display = chatHidden ? 'none' : 'block';
      }

      beginPanelResize(e, which) {
        if (window.innerWidth <= 1024) return; // desktop only
        this.isResizingPanels = true;
        this.activeResizer = which; // 'left' or 'right'
        this.resizeStartX = (e.touches ? e.touches[0].clientX : e.clientX);

        // Snapshot starting widths
        const root = document.documentElement;
        const computed = getComputedStyle(root);
        this.startSidebarWidth = parseInt(computed.getPropertyValue('--sidebar-width')) || 280;
        this.startChatWidth = parseInt(computed.getPropertyValue('--chat-width')) || 360;

        // Prevent text selection during drag
        document.body.classList.add('resizing');
        e.preventDefault?.();
      }

      handlePanelResize(e) {
        if (!this.isResizingPanels || !this.activeResizer) return;
        const x = (e.touches ? e.touches[0].clientX : e.clientX);
        const deltaX = x - this.resizeStartX;

        const root = document.documentElement;
        const minSidebar = 180; // px
        const maxSidebar = 600;
        const minChat = 240;
        const maxChat = 600;

        if (this.activeResizer === 'left') {
          let newWidth = this.startSidebarWidth + deltaX;
          newWidth = Math.max(minSidebar, Math.min(maxSidebar, newWidth));
          root.style.setProperty('--sidebar-width', `${Math.round(newWidth)}px`);
        } else if (this.activeResizer === 'right') {
          // Move left increases chat width (delta negative); adjust accordingly
          let newWidth = this.startChatWidth - deltaX;
          newWidth = Math.max(minChat, Math.min(maxChat, newWidth));
          root.style.setProperty('--chat-width', `${Math.round(newWidth)}px`);
        }

        // Rerender canvas sizing-sensitive elements
        this.adjustViewerAfterLayoutChange();
        e.preventDefault?.();
      }

      endPanelResize() {
        if (!this.isResizingPanels) return;
        this.isResizingPanels = false;
        document.body.classList.remove('resizing');
        // Persist widths
        const root = document.documentElement;
        const computed = getComputedStyle(root);
        const sidebar = parseInt(computed.getPropertyValue('--sidebar-width')) || 280;
        const chat = parseInt(computed.getPropertyValue('--chat-width')) || 360;
        localStorage.setItem('sidebarWidth', String(sidebar));
        localStorage.setItem('chatWidth', String(chat));
        this.activeResizer = null;
      }

      closeOverlaysOnSmallScreen() {
        const width = window.innerWidth;
        
        if (width < 480) {
          this.closeChat();
          this.closeSidebar();
        }
      }

      handleOutsideClick(e) {
        // Close sidebar if clicking outside panel and not on the open button
        const sidebar = document.querySelector('.sidebar');
        if (document.body.classList.contains('sidebar-open')) {
          if (!sidebar.contains(e.target) && !e.target.closest('#open-sidebar')) {
            this.closeSidebar();
          }
        }

        // Close chat if clicking outside panel and not on the open button
        const chat = document.querySelector('.chat');
        if (document.body.classList.contains('chat-open')) {
          if (!chat.contains(e.target) && !e.target.closest('#open-chat')) {
            this.closeChat();
          }
        }

        // Close zoom window if clicking outside
        if (this.zoomWindowActive) {
          const zoomWindow = document.getElementById('zoom-window-overlay');
          if (zoomWindow && !zoomWindow.contains(e.target)) {
            this.closeZoomWindow();
          }
        }
      }

      handleEscapeKey() {
        // Close zoom window
        if (this.zoomWindowActive) {
          this.closeZoomWindow();
          return;
        }

        // Close chat
        if (document.body.classList.contains('chat-open')) {
          this.closeChat();
          return;
        }

        // Close sidebar
        if (document.body.classList.contains('sidebar-open')) {
          this.closeSidebar();
          return;
        }
      }

      // Zoom Window Methods
      setupZoomWindowControls() {
        const zoomWindowBtn = document.getElementById('zoom-window-btn');
        const zoomWindowOverlay = document.getElementById('zoom-window-overlay');
        const zoomWindowClose = document.getElementById('zoom-window-close');
        const returnHeightSlider = document.getElementById('return-height');
        const returnHeightValue = document.getElementById('return-height-value');
        const autoAdvanceCheckbox = document.getElementById('auto-advance');

        if (zoomWindowBtn) {
          zoomWindowBtn.addEventListener('click', () => this.toggleZoomWindow());
        }

        if (zoomWindowClose) {
          zoomWindowClose.addEventListener('click', () => this.closeZoomWindow());
        }

        if (returnHeightSlider) {
          returnHeightSlider.addEventListener('input', (e) => {
            this.returnHeight = parseInt(e.target.value);
            returnHeightValue.textContent = `${this.returnHeight}px`;
          });
        }

        if (autoAdvanceCheckbox) {
          autoAdvanceCheckbox.addEventListener('change', (e) => {
            this.autoAdvance = e.target.checked;
          });
        }

        // Initialize zoom box references
        this.zoomBox = document.getElementById('zoom-box');
        this.zoomBoxContent = document.getElementById('zoom-box-content');
        
        if (this.zoomBox) {
          this.setupZoomBoxInteractions();
        }
      }

      toggleZoomWindow() {
        const zoomWindowOverlay = document.getElementById('zoom-window-overlay');
        const writingToolsOverlay = document.getElementById('writing-tools-overlay');
        
        if (this.zoomWindowActive) {
          this.closeZoomWindow();
        } else {
          this.openZoomWindow();
        }
      }

      openZoomWindow() {
        const zoomWindowOverlay = document.getElementById('zoom-window-overlay');
        const writingToolsOverlay = document.getElementById('writing-tools-overlay');
        
        if (zoomWindowOverlay) {
          zoomWindowOverlay.style.display = 'flex';
          this.zoomWindowActive = true;
          
          // Show writing tools
          if (writingToolsOverlay) {
            writingToolsOverlay.style.display = 'block';
          }
          
          // Update zoom box content with current PDF page
          this.updateZoomBoxContent();
        }
      }

      closeZoomWindow() {
        const zoomWindowOverlay = document.getElementById('zoom-window-overlay');
        const writingToolsOverlay = document.getElementById('writing-tools-overlay');
        
        if (zoomWindowOverlay) {
          zoomWindowOverlay.style.display = 'none';
          this.zoomWindowActive = false;
          
          // Hide writing tools
          if (writingToolsOverlay) {
            writingToolsOverlay.style.display = 'none';
          }
        }
      }

      setupZoomBoxInteractions() {
        if (!this.zoomBox) return;

        // Mouse events for dragging
        this.zoomBox.addEventListener('mousedown', (e) => this.handleZoomBoxMouseDown(e));
        document.addEventListener('mousemove', (e) => this.handleZoomBoxMouseMove(e));
        document.addEventListener('mouseup', (e) => this.handleZoomBoxMouseUp(e));

        // Touch events for mobile
        this.zoomBox.addEventListener('touchstart', (e) => this.handleZoomBoxTouchStart(e), { passive: false });
        document.addEventListener('touchmove', (e) => this.handleZoomBoxTouchMove(e), { passive: false });
        document.addEventListener('touchend', (e) => this.handleZoomBoxTouchEnd(e), { passive: false });

        // Resize handle events
        const resizeHandles = this.zoomBox.querySelectorAll('.resize-handle');
        resizeHandles.forEach(handle => {
          handle.addEventListener('mousedown', (e) => this.handleResizeStart(e));
          handle.addEventListener('touchstart', (e) => this.handleResizeStart(e), { passive: false });
        });
      }

      handleZoomBoxMouseDown(e) {
        if (e.target.classList.contains('resize-handle')) return;
        
        this.isDraggingZoomBox = true;
        this.dragStart = { x: e.clientX, y: e.clientY };
        e.preventDefault();
      }

      handleZoomBoxMouseMove(e) {
        if (!this.isDraggingZoomBox) return;
        
        const deltaX = e.clientX - this.dragStart.x;
        const deltaY = e.clientY - this.dragStart.y;
        
        this.zoomBoxPosition.x += deltaX;
        this.zoomBoxPosition.y += deltaY;
        
        this.updateZoomBoxPosition();
        this.dragStart = { x: e.clientX, y: e.clientY };
      }

      handleZoomBoxMouseUp(e) {
        this.isDraggingZoomBox = false;
        this.isResizingZoomBox = false;
        this.resizeDirection = null;
      }

      handleZoomBoxTouchStart(e) {
        if (e.target.classList.contains('resize-handle')) return;
        
        this.isDraggingZoomBox = true;
        const touch = e.touches[0];
        this.dragStart = { x: touch.clientX, y: touch.clientY };
        e.preventDefault();
      }

      handleZoomBoxTouchMove(e) {
        if (!this.isDraggingZoomBox) return;
        
        const touch = e.touches[0];
        const deltaX = touch.clientX - this.dragStart.x;
        const deltaY = touch.clientY - this.dragStart.y;
        
        this.zoomBoxPosition.x += deltaX;
        this.zoomBoxPosition.y += deltaY;
        
        this.updateZoomBoxPosition();
        this.dragStart = { x: touch.clientX, y: touch.clientY };
        e.preventDefault();
      }

      handleZoomBoxTouchEnd(e) {
        this.isDraggingZoomBox = false;
        this.isResizingZoomBox = false;
        this.resizeDirection = null;
      }

      handleResizeStart(e) {
        this.isResizingZoomBox = true;
        this.resizeDirection = e.target.dataset.direction;
        this.dragStart = { x: e.clientX || e.touches[0].clientX, y: e.clientY || e.touches[0].clientY };
        e.preventDefault();
      }

      updateZoomBoxPosition() {
        if (!this.zoomBox) return;
        
        const container = this.zoomBox.parentElement;
        const containerRect = container.getBoundingClientRect();
        
        // Constrain to container bounds
        this.zoomBoxPosition.x = Math.max(0, Math.min(this.zoomBoxPosition.x, containerRect.width - this.zoomBoxSize.width));
        this.zoomBoxPosition.y = Math.max(0, Math.min(this.zoomBoxPosition.y, containerRect.height - this.zoomBoxSize.height));
        
        this.zoomBox.style.left = `${this.zoomBoxPosition.x}px`;
        this.zoomBox.style.top = `${this.zoomBoxPosition.y}px`;
        this.zoomBox.style.transform = 'none';
      }

      updateZoomBoxContent() {
        if (!this.zoomBoxContent || !this.pdfDoc) return;
        
        // Create a canvas for the zoomed content
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        
        // Set canvas size to match zoom box
        canvas.width = this.zoomBoxSize.width;
        canvas.height = this.zoomBoxSize.height;
        
        // Calculate the source area from the main PDF canvas
        const mainCanvas = document.getElementById('pdf-canvas');
        if (mainCanvas) {
          const mainContext = mainCanvas.getContext('2d');
          const imageData = mainContext.getImageData(0, 0, mainCanvas.width, mainCanvas.height);
          
          // Draw the zoomed content
          context.putImageData(imageData, 0, 0);
        }
        
        // Clear and add the canvas
        this.zoomBoxContent.innerHTML = '';
        this.zoomBoxContent.appendChild(canvas);
        
        // Setup drawing on the zoom box content
        this.setupZoomBoxDrawing(canvas);
      }

      setupZoomBoxDrawing(canvas) {
        if (!canvas) return;
        
        const context = canvas.getContext('2d');
        
        // Mouse events for drawing
        canvas.addEventListener('mousedown', (e) => this.startDrawing(e, context));
        canvas.addEventListener('mousemove', (e) => this.draw(e, context));
        canvas.addEventListener('mouseup', () => this.stopDrawing());
        canvas.addEventListener('mouseout', () => this.stopDrawing());
        
        // Touch events for drawing
        canvas.addEventListener('touchstart', (e) => this.startDrawing(e, context), { passive: false });
        canvas.addEventListener('touchmove', (e) => this.draw(e, context), { passive: false });
        canvas.addEventListener('touchend', () => this.stopDrawing());
      }

      // Writing Tools Methods
      setupWritingToolsControls() {
        // Tool selection
        const penTool = document.getElementById('pen-tool');
        const highlighterTool = document.getElementById('highlighter-tool');
        const eraserTool = document.getElementById('eraser-tool');
        const lassoTool = document.getElementById('lasso-tool');
        const shapeTool = document.getElementById('shape-tool');
        const textTool = document.getElementById('text-tool');

        if (penTool) penTool.addEventListener('click', () => this.selectTool('pen'));
        if (highlighterTool) highlighterTool.addEventListener('click', () => this.selectTool('highlighter'));
        if (eraserTool) eraserTool.addEventListener('click', () => this.selectTool('eraser'));
        if (lassoTool) lassoTool.addEventListener('click', () => this.selectTool('lasso'));
        if (shapeTool) shapeTool.addEventListener('click', () => this.selectTool('shape'));
        if (textTool) textTool.addEventListener('click', () => this.selectTool('text'));

        // Color palette
        const colorOptions = document.querySelectorAll('.color-option');
        colorOptions.forEach(option => {
          option.addEventListener('click', (e) => {
            this.selectColor(e.target.dataset.color);
            this.updateColorSelection(e.target);
          });
        });

        // Size options
        const sizeOptions = document.querySelectorAll('.size-option');
        sizeOptions.forEach(option => {
          option.addEventListener('click', (e) => {
            this.penSize = parseInt(e.target.dataset.size);
            this.updateSizeSelection(e.target);
            this.updateSizeDisplay();
          });
        });

        // Sliders
        const penSizeSlider = document.getElementById('pen-size');
        const penOpacitySlider = document.getElementById('pen-opacity');
        const zoomFactorSlider = document.getElementById('zoom-factor');

        if (penSizeSlider) {
          penSizeSlider.addEventListener('input', (e) => {
            this.penSize = parseInt(e.target.value);
            this.updateSizeDisplay();
          });
        }

        if (penOpacitySlider) {
          penOpacitySlider.addEventListener('input', (e) => {
            this.penOpacity = parseFloat(e.target.value);
            this.updateOpacityDisplay();
          });
        }

        if (zoomFactorSlider) {
          zoomFactorSlider.addEventListener('input', (e) => {
            this.zoomFactor = parseInt(e.target.value) / 100;
            this.updateZoomFactorDisplay();
            this.updateZoomBoxContent();
          });
        }

        // Action buttons
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const clearBtn = document.getElementById('clear-btn');
        const saveBtn = document.getElementById('save-btn');

        if (undoBtn) undoBtn.addEventListener('click', () => this.undo());
        if (redoBtn) redoBtn.addEventListener('click', () => this.redo());
        if (clearBtn) clearBtn.addEventListener('click', () => this.clearCanvas());
        if (saveBtn) saveBtn.addEventListener('click', () => this.saveAnnotations());

        // Shape tools
        this.setupShapeTools();
        
        // Settings panel
        this.setupSettingsPanel();
      }

      setupShapeTools() {
        const shapeButtons = document.querySelectorAll('.shape-btn');
        shapeButtons.forEach(btn => {
          btn.addEventListener('click', (e) => {
            this.currentShape = e.target.dataset.shape;
            this.updateShapeSelection(e.target);
          });
        });
      }

      setupSettingsPanel() {
        const settingsBtn = document.getElementById('zoom-window-settings');
        const settingsPanel = document.getElementById('zoom-window-settings-panel');
        const pressureSensitivity = document.getElementById('pressure-sensitivity');
        const handwritingRecognition = document.getElementById('handwriting-recognition');

        if (settingsBtn && settingsPanel) {
          settingsBtn.addEventListener('click', () => {
            const isVisible = settingsPanel.style.display !== 'none';
            settingsPanel.style.display = isVisible ? 'none' : 'block';
          });
        }

        if (pressureSensitivity) {
          pressureSensitivity.addEventListener('change', (e) => {
            this.pressureSensitivity = e.target.checked;
          });
        }

        if (handwritingRecognition) {
          handwritingRecognition.addEventListener('change', (e) => {
            this.handwritingRecognition = e.target.checked;
          });
        }
      }

      selectTool(tool) {
        this.currentTool = tool;
        
        // Update active tool button
        document.querySelectorAll('.tool-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        
        const toolBtn = document.getElementById(`${tool}-tool`);
        if (toolBtn) {
          toolBtn.classList.add('active');
        }

        // Show/hide shape tools panel
        const shapePanel = document.getElementById('shape-tools-panel');
        if (shapePanel) {
          shapePanel.style.display = tool === 'shape' ? 'block' : 'none';
        }

        // Update cursor based on tool
        this.updateCursor(tool);
      }

      selectColor(color) {
        this.penColor = color;
      }

      updateColorSelection(selectedElement) {
        document.querySelectorAll('.color-option').forEach(option => {
          option.classList.remove('active');
        });
        selectedElement.classList.add('active');
      }

      updateSizeSelection(selectedElement) {
        document.querySelectorAll('.size-option').forEach(option => {
          option.classList.remove('active');
        });
        selectedElement.classList.add('active');
      }

      updateShapeSelection(selectedElement) {
        document.querySelectorAll('.shape-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        selectedElement.classList.add('active');
      }

      updateSizeDisplay() {
        const sizeValue = document.getElementById('pen-size-value');
        if (sizeValue) {
          sizeValue.textContent = `${this.penSize}px`;
        }
      }

      updateOpacityDisplay() {
        const opacityValue = document.getElementById('pen-opacity-value');
        if (opacityValue) {
          opacityValue.textContent = `${Math.round(this.penOpacity * 100)}%`;
        }
      }

      updateZoomFactorDisplay() {
        const zoomValue = document.getElementById('zoom-factor-value');
        const zoomIndicator = document.getElementById('zoom-level-indicator');
        const zoomPercent = Math.round(this.zoomFactor * 100);
        
        if (zoomValue) zoomValue.textContent = `${zoomPercent}%`;
        if (zoomIndicator) zoomIndicator.textContent = `${zoomPercent}%`;
      }

      updateCursor(tool) {
        const canvas = document.getElementById('writing-canvas');
        if (!canvas) return;

        const cursors = {
          pen: 'crosshair',
          highlighter: 'crosshair',
          eraser: 'grab',
          lasso: 'crosshair',
          shape: 'crosshair',
          text: 'text'
        };

        canvas.style.cursor = cursors[tool] || 'default';
      }

      startDrawing(e, context) {
        if (!this.zoomWindowActive) return;
        
        this.isDrawing = true;
        this.drawingPath = [];
        
        const rect = e.target.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        
        // Get pressure if available
        const pressure = this.getPressure(e);
        
        this.drawingPath.push({ x, y, pressure, timestamp: Date.now() });
        
        // Handle different tools
        switch (this.currentTool) {
          case 'pen':
            this.setupPenDrawing(context, pressure);
            break;
          case 'highlighter':
            this.setupHighlighterDrawing(context, pressure);
            break;
          case 'eraser':
            this.handleScribbleToErase(e, context);
            return;
          case 'lasso':
            this.handleCircleToLasso(e, context);
            return;
          case 'shape':
            this.startShapeDrawing(x, y);
            return;
          case 'text':
            this.startTextInput(x, y);
            return;
        }
        
        context.beginPath();
        context.moveTo(x, y);
        
        e.preventDefault();
      }

      getPressure(e) {
        if (this.pressureSensitivity && e.pressure !== undefined) {
          return Math.max(0.1, Math.min(1.0, e.pressure));
        }
        return 1.0;
      }

      setupPenDrawing(context, pressure = 1.0) {
        const size = this.penSize * pressure;
        context.strokeStyle = this.penColor;
        context.lineWidth = size;
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.globalCompositeOperation = 'source-over';
        context.globalAlpha = this.penOpacity;
      }

      setupHighlighterDrawing(context, pressure = 1.0) {
        const size = this.penSize * 3 * pressure; // Highlighter is thicker
        context.strokeStyle = this.penColor;
        context.lineWidth = size;
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.globalCompositeOperation = 'multiply'; // Highlighter effect
        context.globalAlpha = 0.3;
      }

      startShapeDrawing(x, y) {
        this.isDrawingShape = true;
        this.shapeStartPoint = { x, y };
      }

      startTextInput(x, y) {
        const text = prompt('Enter text:');
        if (text) {
          this.addTextToCanvas(text, x, y);
        }
      }

      addTextToCanvas(text, x, y) {
        const canvas = document.getElementById('writing-canvas');
        if (!canvas) return;

        const context = canvas.getContext('2d');
        context.font = `${this.penSize * 4}px Arial`;
        context.fillStyle = this.penColor;
        context.globalAlpha = this.penOpacity;
        context.fillText(text, x, y);

        // Save to history
        this.saveToHistory({
          type: 'text',
          text: text,
          x: x,
          y: y,
          color: this.penColor,
          size: this.penSize,
          opacity: this.penOpacity
        });
      }

      draw(e, context) {
        if (!this.isDrawing || !this.zoomWindowActive) return;
        
        const rect = e.target.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        
        this.drawingPath.push({ x, y });
        
        // Handle different tools
        switch (this.currentTool) {
          case 'pen':
            context.lineTo(x, y);
            context.stroke();
            break;
          case 'eraser':
            this.handleScribbleToErase(e, context);
            break;
          case 'lasso':
            this.handleCircleToLasso(e, context);
            break;
          case 'math':
            this.handleMathConversion(e, context);
            break;
        }
        
        // Check for auto-advance (only for pen tool)
        if (this.currentTool === 'pen' && this.autoAdvance && this.shouldAutoAdvance(x, y)) {
          this.autoAdvanceToNextLine();
        }
        
        e.preventDefault();
      }

      stopDrawing() {
        if (!this.isDrawing) return;
        
        this.isDrawing = false;
        
        // Save drawing to history
        if (this.drawingPath.length > 0) {
          this.saveToHistory({
            type: 'drawing',
            path: [...this.drawingPath],
            tool: this.currentTool,
            color: this.penColor,
            size: this.penSize,
            opacity: this.penOpacity
          });
        }
        
        this.drawingPath = [];
      }

      saveToHistory(action) {
        this.drawingHistory.push(action);
        this.undoStack.push(JSON.parse(JSON.stringify(this.drawingHistory)));
        this.redoStack = []; // Clear redo stack when new action is performed
        
        // Limit history size
        if (this.undoStack.length > 50) {
          this.undoStack.shift();
        }
      }

      undo() {
        if (this.undoStack.length > 1) {
          this.redoStack.push(this.undoStack.pop());
          this.drawingHistory = JSON.parse(JSON.stringify(this.undoStack[this.undoStack.length - 1]));
          this.redrawCanvas();
        }
      }

      redo() {
        if (this.redoStack.length > 0) {
          const action = this.redoStack.pop();
          this.undoStack.push(action);
          this.drawingHistory = JSON.parse(JSON.stringify(action));
          this.redrawCanvas();
        }
      }

      clearCanvas() {
        if (confirm('Are you sure you want to clear all annotations?')) {
          this.drawingHistory = [];
          this.undoStack = [];
          this.redoStack = [];
          this.redrawCanvas();
        }
      }

      saveAnnotations() {
        const canvas = document.getElementById('writing-canvas');
        if (!canvas) return;

        // Create download link
        const link = document.createElement('a');
        link.download = `annotations-${Date.now()}.png`;
        link.href = canvas.toDataURL();
        link.click();

        // Also save as JSON for later editing
        const annotations = {
          history: this.drawingHistory,
          metadata: {
            created: new Date().toISOString(),
            tool: this.currentTool,
            color: this.penColor,
            size: this.penSize
          }
        };

        const jsonBlob = new Blob([JSON.stringify(annotations, null, 2)], {
          type: 'application/json'
        });
        const jsonLink = document.createElement('a');
        jsonLink.download = `annotations-${Date.now()}.json`;
        jsonLink.href = URL.createObjectURL(jsonBlob);
        jsonLink.click();
      }

      shouldAutoAdvance(x, y) {
        // Check if drawing has exceeded the middle of the zoom box
        return y > this.zoomBoxSize.height / 2;
      }

      autoAdvanceToNextLine() {
        // Move the zoom box down by return height
        this.zoomBoxPosition.y += this.returnHeight;
        this.updateZoomBoxPosition();
        this.updateZoomBoxContent();
      }

      // Advanced Writing Features
      handleScribbleToErase(e, context) {
        if (this.currentTool !== 'eraser') return;
        
        const rect = e.target.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        
        // Use composite operation to erase
        context.globalCompositeOperation = 'destination-out';
        context.lineWidth = this.penSize * 2; // Make eraser larger
        context.lineCap = 'round';
        context.lineJoin = 'round';
        
        if (e.type === 'mousedown' || e.type === 'touchstart') {
          context.beginPath();
          context.moveTo(x, y);
        } else if (e.type === 'mousemove' || e.type === 'touchmove') {
          context.lineTo(x, y);
          context.stroke();
        }
        
        // Reset composite operation
        context.globalCompositeOperation = 'source-over';
      }

      handleCircleToLasso(e, context) {
        if (this.currentTool !== 'lasso') return;
        
        const rect = e.target.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        
        // Draw lasso selection
        context.strokeStyle = '#007AFF';
        context.lineWidth = 2;
        context.setLineDash([5, 5]);
        context.lineCap = 'round';
        
        if (e.type === 'mousedown' || e.type === 'touchstart') {
          this.lassoStart = { x, y };
          context.beginPath();
          context.moveTo(x, y);
        } else if (e.type === 'mousemove' || e.type === 'touchmove') {
          context.lineTo(x, y);
          context.stroke();
        } else if (e.type === 'mouseup' || e.type === 'touchend') {
          // Complete the lasso selection
          context.lineTo(this.lassoStart.x, this.lassoStart.y);
          context.stroke();
          context.setLineDash([]);
          
          // Select objects within the lasso area
          this.selectObjectsInLasso();
        }
      }

      selectObjectsInLasso() {
        // Find and select drawing objects within the lasso area
        const selectedObjects = [];
        
        this.drawingHistory.forEach((drawing, index) => {
          if (this.isObjectInLasso(drawing)) {
            selectedObjects.push(index);
          }
        });
        
        if (selectedObjects.length > 0) {
          this.showObjectMenu(selectedObjects);
        }
      }

      isObjectInLasso(drawing) {
        // Check if any point in the drawing path is within the lasso area
        return drawing.path.some(point => {
          return this.isPointInLasso(point);
        });
      }

      isPointInLasso(point) {
        // Simple point-in-polygon test for lasso selection
        // This is a simplified version - in a real implementation,
        // you'd want to use a more robust algorithm
        return true; // Placeholder
      }

      showObjectMenu(selectedObjects) {
        // Create context menu for selected objects
        const menu = document.createElement('div');
        menu.className = 'object-menu';
        menu.innerHTML = `
          <div class="menu-item" data-action="move">Move</div>
          <div class="menu-item" data-action="resize">Resize</div>
          <div class="menu-item" data-action="color">Change Color</div>
          <div class="menu-item" data-action="delete">Delete</div>
        `;
        
        // Position menu at cursor location
        menu.style.position = 'absolute';
        menu.style.left = this.lassoStart.x + 'px';
        menu.style.top = this.lassoStart.y + 'px';
        menu.style.background = 'white';
        menu.style.border = '1px solid #ccc';
        menu.style.borderRadius = '8px';
        menu.style.padding = '8px';
        menu.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
        menu.style.zIndex = '1000';
        
        // Add event listeners
        menu.addEventListener('click', (e) => {
          const action = e.target.dataset.action;
          this.handleObjectAction(action, selectedObjects);
          menu.remove();
        });
        
        // Add to document
        document.body.appendChild(menu);
        
        // Remove menu when clicking outside
        setTimeout(() => {
          document.addEventListener('click', () => menu.remove(), { once: true });
        }, 100);
      }

      handleObjectAction(action, selectedObjects) {
        switch (action) {
          case 'move':
            this.moveSelectedObjects(selectedObjects);
            break;
          case 'resize':
            this.resizeSelectedObjects(selectedObjects);
            break;
          case 'color':
            this.changeColorSelectedObjects(selectedObjects);
            break;
          case 'delete':
            this.deleteSelectedObjects(selectedObjects);
            break;
        }
      }

      moveSelectedObjects(selectedObjects) {
        // Implement object movement
        console.log('Moving objects:', selectedObjects);
      }

      resizeSelectedObjects(selectedObjects) {
        // Implement object resizing
        console.log('Resizing objects:', selectedObjects);
      }

      changeColorSelectedObjects(selectedObjects) {
        // Show color picker and update selected objects
        const colorPicker = document.createElement('input');
        colorPicker.type = 'color';
        colorPicker.addEventListener('change', (e) => {
          selectedObjects.forEach(index => {
            this.drawingHistory[index].color = e.target.value;
          });
          this.redrawCanvas();
        });
        colorPicker.click();
      }

      deleteSelectedObjects(selectedObjects) {
        // Remove selected objects from history
        selectedObjects.sort((a, b) => b - a); // Sort in descending order
        selectedObjects.forEach(index => {
          this.drawingHistory.splice(index, 1);
        });
        this.redrawCanvas();
      }

      redrawCanvas() {
        // Redraw the entire canvas with updated drawing history
        const canvas = document.getElementById('writing-canvas');
        if (!canvas) return;
        
        const context = canvas.getContext('2d');
        context.clearRect(0, 0, canvas.width, canvas.height);
        
        // Redraw all drawings
        this.drawingHistory.forEach(action => {
          if (action.type === 'drawing') {
            this.redrawDrawing(context, action);
          } else if (action.type === 'text') {
            this.redrawText(context, action);
          } else if (action.type === 'shape') {
            this.redrawShape(context, action);
          }
        });
      }

      redrawDrawing(context, action) {
        context.strokeStyle = action.color;
        context.lineWidth = action.size;
        context.lineCap = 'round';
        context.lineJoin = 'round';
        context.globalAlpha = action.opacity || 1;
        
        // Set composite operation based on tool
        if (action.tool === 'highlighter') {
          context.globalCompositeOperation = 'multiply';
        } else {
          context.globalCompositeOperation = 'source-over';
        }
        
        context.beginPath();
        action.path.forEach((point, index) => {
          const size = action.size * (point.pressure || 1);
          context.lineWidth = size;
          
          if (index === 0) {
            context.moveTo(point.x, point.y);
          } else {
            context.lineTo(point.x, point.y);
          }
        });
        context.stroke();
        
        // Reset composite operation
        context.globalCompositeOperation = 'source-over';
        context.globalAlpha = 1;
      }

      redrawText(context, action) {
        context.font = `${action.size * 4}px Arial`;
        context.fillStyle = action.color;
        context.globalAlpha = action.opacity || 1;
        context.fillText(action.text, action.x, action.y);
        context.globalAlpha = 1;
      }

      redrawShape(context, action) {
        context.strokeStyle = action.color;
        context.lineWidth = action.size;
        context.globalAlpha = action.opacity || 1;
        
        context.beginPath();
        this.drawShape(context, action.shape, action.startPoint, action.endPoint);
        context.stroke();
        context.globalAlpha = 1;
      }

      drawShape(context, shapeType, startPoint, endPoint) {
        const width = endPoint.x - startPoint.x;
        const height = endPoint.y - startPoint.y;
        
        switch (shapeType) {
          case 'rectangle':
            context.rect(startPoint.x, startPoint.y, width, height);
            break;
          case 'circle':
            const radius = Math.sqrt(width * width + height * height) / 2;
            context.arc(startPoint.x + width/2, startPoint.y + height/2, radius, 0, 2 * Math.PI);
            break;
          case 'line':
            context.moveTo(startPoint.x, startPoint.y);
            context.lineTo(endPoint.x, endPoint.y);
            break;
          case 'arrow':
            context.moveTo(startPoint.x, startPoint.y);
            context.lineTo(endPoint.x, endPoint.y);
            // Add arrowhead
            const angle = Math.atan2(height, width);
            const arrowLength = 20;
            context.lineTo(
              endPoint.x - arrowLength * Math.cos(angle - Math.PI / 6),
              endPoint.y - arrowLength * Math.sin(angle - Math.PI / 6)
            );
            context.moveTo(endPoint.x, endPoint.y);
            context.lineTo(
              endPoint.x - arrowLength * Math.cos(angle + Math.PI / 6),
              endPoint.y - arrowLength * Math.sin(angle + Math.PI / 6)
            );
            break;
        }
      }

      // Math Conversion Feature
      handleMathConversion(e, context) {
        if (this.currentTool !== 'math') return;
        
        // This would integrate with a math recognition API
        // For now, we'll show a placeholder
        const rect = e.target.getBoundingClientRect();
        const x = (e.clientX || e.touches[0].clientX) - rect.left;
        const y = (e.clientY || e.touches[0].clientY) - rect.top;
        
        // Show math conversion indicator
        context.fillStyle = '#007AFF';
        context.fillRect(x - 10, y - 10, 20, 20);
        
        // In a real implementation, you would:
        // 1. Capture the drawn math expression
        // 2. Send it to a math recognition service
        // 3. Convert it to LaTeX or formatted text
        // 4. Replace the handwritten math with formatted text
      }
    }

    // Initialize the app when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      new StudyPDFApp();
    });
  </script>
</body>
</html>
